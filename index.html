<!DOCTYPE html>
<html lang="fr">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover">
<title>Lecteur chinois mot-Ã -mot</title>

<!-- Pickr (color pickers) -->
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@simonwep/pickr/dist/themes/classic.min.css"/>
<script src="https://cdn.jsdelivr.net/npm/@simonwep/pickr"></script>

<!-- Fonts -->
<link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600;700;800&family=Noto+Sans+SC:wght@500;600;700;800&display=swap" rel="stylesheet">

<style>
/* =====================================================
   Variables & Reset
   ===================================================== */
:root{
  --bg:#f6f8fb;
  --card:#ffffff;
  --brand:#0a84ff;
  --muted:#667085;
  --ring:rgba(10,132,255,.25);
  --radius:14px;
  --shadow:0 10px 28px rgba(20,20,20,.08);
  --space:clamp(14px,2.8vw,22px);
  --base:clamp(16px,3.8vw,18px);
  --h1:clamp(22px,7.2vw,34px);
  --chip:clamp(20px,5.6vw,24px);
  --textEdit:clamp(18px,4.8vw,20px);
}

*{ box-sizing:border-box }
html,body{ height:100% }
body{
  margin:0;
  font-family:"Inter",system-ui,Arial,sans-serif;
  background:transparent;
  color:#1f2937;
  font-size:var(--base);
  -webkit-text-size-adjust:100%;
}

/* =====================================================
   Home page layout
   ===================================================== */
.container{
  max-width:840px;
  margin:0 auto;
  padding:calc(var(--space) * 0.75);
}
.card{
  background:var(--card);
  border-radius:var(--radius);
  box-shadow:var(--shadow);
  padding:var(--space);
}
h1{
  font-size:var(--h1);
  text-align:center;
  margin:0 0 10px;
  color:#1976d2;
  font-weight:800;
  letter-spacing:.2px;
}

/* Mode Selector */
.mode-selector {
  display: flex;
  justify-content: center;
  gap: 20px;
  margin: 20px 0 30px;
  padding: 20px;
  background: #f0f5ff;
  border-radius: var(--radius);
}

.mode-option {
  flex: 1;
  max-width: 250px;
  text-align: center;
  cursor: pointer;
  transition: transform 0.2s ease;
}

.mode-option:hover {
  transform: translateY(-2px);
}

.mode-option input[type="radio"] {
  display: none;
}

.mode-label {
  display: block;
  padding: 20px;
  border: 3px solid #e0e7ff;
  border-radius: 12px;
  background: white;
  transition: all 0.2s ease;
}

.mode-option input[type="radio"]:checked + .mode-label {
  border-color: var(--brand);
  background: #f0f9ff;
  box-shadow: 0 4px 12px rgba(10,132,255,0.2);
}

.mode-icon {
  font-size: 32px;
  margin-bottom: 8px;
}

.mode-title {
  font-size: 18px;
  font-weight: 700;
  color: #1f2937;
  margin-bottom: 4px;
}

.mode-desc {
  font-size: 13px;
  color: var(--muted);
}

/* Game Mode Options */
.game-mode-options {
  background: #f9fafb;
  border: 1px solid #e5e7eb;
  border-radius: 12px;
  padding: 16px;
  margin-top: 16px;
  display: none;
}

.game-mode-title {
  font-weight: 700;
  color: #111827;
  margin-bottom: 12px;
  font-size: 14px;
}

.game-mode-grid {
  display: grid;
  grid-template-columns: repeat(2, 1fr);
  gap: 12px;
}

.game-mode-item {
  display: flex;
  align-items: center;
  gap: 10px;
}

.game-mode-item input[type="radio"] {
  width: 18px;
  height: 18px;
  cursor: pointer;
}

.game-mode-item label {
  cursor: pointer;
  font-size: 14px;
  font-weight: 600;
  color: #374151;
}

/* CTA bas de page (Accueil) */
.cta-bar{
  position:sticky;
  bottom:max(12px, env(safe-area-inset-bottom));
  display:flex;
  justify-content:center;
  margin-top:var(--space);
  z-index:5;
}

/* =====================================================
   Buttons (generic)
   ===================================================== */
button:not(.ctrl-btn){
  appearance:none;
  border:none;
  border-radius:12px;
  padding:14px 20px;
  font-weight:700;
  cursor:pointer;
  transition:transform .06s ease, box-shadow .2s ease, background .2s ease;
}
.btn-primary{
  background:var(--brand);
  color:#fff;
  box-shadow:0 6px 18px rgba(10,132,255,.25);
}
.btn-primary:active{ transform:scale(.98) }
.btn-ghost{ background:#eef2f7; color:#111827 }

/* =====================================================
   Editor / Segmentation
   ===================================================== */
.input-wrap{ position:relative }
textarea{
  width:100%;
  min-height:170px;
  padding:16px 18px;
  font-family:"Noto Sans SC","Inter",sans-serif;
  font-size:var(--textEdit);
  font-weight:600;
  line-height:1.65;
  background:#fff;
  color:#111827;
  border:1px solid #e5e7eb;
  border-radius:12px;
  outline:none;
  box-shadow:inset 0 1px 0 rgba(16,24,40,.02);
}
textarea:focus{ border-color:var(--brand); box-shadow:0 0 0 4px var(--ring) }

.editor-actions{
  margin-top: 6px;
  display: flex;
  justify-content: space-between;
  align-items: center;
}

.editor-btn{
  display: flex;
  align-items: center;
  justify-content: center;
  width: 32px;
  height: 32px;
  border: none;
  border-radius: 8px;
  cursor: pointer;
  background: #f3f4f6;
  box-shadow: 0 1px 3px rgba(0,0,0,.15);
  color: #111827;
  transition: background 0.2s, color 0.2s;
  transform: translateY(-3px)
}

.editor-btn:hover {
  background: #e5e7eb;
}

#clearText{
  background: none;
  box-shadow: none;
  color: #dc2626;
}

#clearText .icon {
  width: 28px;
  height: 28px;
  stroke: currentColor;
  fill: none;
}

#clearText:hover {
  background: none;
  color: #b91c1c;
}

.icon {
  width: 18px;
  height: 18px;
  flex-shrink: 0;
  display: block;
}

#toggleEdit {
  background: none;
  box-shadow: none;
  color: var(--brand);
}

#toggleEdit:hover {
  color: #0066cc;
}

#toggleEdit.icon {
  fill: currentColor;
  stroke: none;
}

.editor-btn .icon{
  width: 22px;
  height: 22px;
  display: block;
  flex-shrink: 0;
  pointer-events: none;
  fill: currentColor;
  stroke: currentColor;
}

.segmented-box{
  border:1px dashed #d8dee9;
  border-radius:12px;
  padding:10px 10px 14px;
  min-height:160px;
  background:#fafcff;
}

#segmentedText{
  overflow-x:auto; overflow-y:hidden;
  white-space:nowrap;
  -webkit-overflow-scrolling:touch;
  padding:4px 2px;
}

.token{
  display:inline-block;
  margin:6px 8px;
  padding:8px 12px;
  border-radius:999px;
  background:#f1f5f9;
  color:#0f172a;
  font-family:"Noto Sans SC","Inter",sans-serif;
  font-size:var(--chip);
  font-weight:700;
  letter-spacing:.5px;
  user-select:none;
  transition:transform .12s ease, background .2s ease, color .2s ease;
}

.token:hover{ transform:translateY(-1px) }
#segmentedText .selected{ background:#ef4444; color:#fff; transform:scale(1.04) }

/* Fieldsets */
fieldset{
  border:1px solid #e5e7eb;
  border-radius:14px;
  padding:16px;
  margin:var(--space) 0;
  background:#fff;
}
legend{ font-weight:800; color:#0f172a; padding:0 8px }

/* Slider */
.range{
  width:100%;
  margin-top:8px;
  -webkit-appearance:none; appearance:none; height:10px;
  background:linear-gradient(90deg,var(--brand),#93c5fd);
  border-radius:999px; outline:none;
}
.range::-webkit-slider-thumb{
  -webkit-appearance:none; appearance:none;
  width:28px; height:28px; border-radius:50%;
  background:#fff; border:3px solid var(--brand);
  box-shadow:0 2px 8px rgba(16,24,40,.2);
}
.range::-moz-range-thumb{
  width:28px; height:28px; border-radius:50%;
  background:#fff; border:3px solid var(--brand);
  box-shadow:0 2px 8px rgba(16,24,40,.2);
}

/* Switches */
.opt{ display:flex; align-items:center; gap:12px; margin:10px 0 }
.opt input[type="checkbox"]{
  appearance:none; width:54px; height:32px; border-radius:999px;
  background:#e5e7eb; position:relative; outline:none; cursor:pointer;
  transition:background .2s ease;
}
.opt input[type="checkbox"]::after{
  content:""; position:absolute; top:3px; left:3px;
  width:26px; height:26px; border-radius:50%;
  background:#fff; box-shadow:0 1px 4px rgba(0,0,0,.2);
  transition:left .2s ease;
}
.opt input[type="checkbox"]:checked{ background:var(--brand) }
.opt input[type="checkbox"]:checked::after{ left:25px }
.opt span{ font-weight:600; color:#111827 }

/* Pickr rows */
.color-row{
  display:flex; justify-content:space-between; gap:18px; flex-wrap:wrap; padding:8px 0;
}
.swatch{ flex:1; min-width:130px; text-align:center }
.swatch > div .pcr-button{
  width:60px; height:60px; border-radius:50%;
  box-shadow:0 3px 10px rgba(0,0,0,.12); border:none;
}
.swatch label{ margin-top:6px; font-weight:600; font-size:14px; display:block }

/* =====================================================
   Selection overlay
   ===================================================== */
#selectionOverlay .overlay-content {
  background: #ffffff;
  border-radius: 12px;
  box-shadow: 0 6px 20px rgba(0,0,0,.2);
  width: 100%;
  max-width: 760px;
  padding: 0;
  display: flex;
  flex-direction: column;
  max-height: 90vh;
}

#overlayHeader{
  flex-shrink: 0;
  padding: 12px;
  background:#f5f5f5;
  border-bottom:1px solid #ddd;
}

#closeOverlay{ background:transparent; border:none; font-size:28px; cursor:pointer; color:#444 }

#segmentedOverlayText {
  flex: 1;
  overflow-y: auto;
  padding: 16px;
  white-space: normal;
  line-height: 1.8;
}

#segmentedOverlayText span{
  display:inline-block; margin:6px 8px; padding:8px 12px;
  border-radius:6px; background:#f1f5f9; font-size:22px; font-weight:600; cursor:pointer;
}

#segmentedOverlayText span.selected{ background:#ef4444; color:#fff }

.bar-hidden {
  opacity: 0;
  pointer-events: none;
  transform: translateY(20px);
  transition: opacity 0.15s ease, transform 0.15s ease;
}

.bar-visible {
  opacity: 1;
  pointer-events: auto;
  transform: translateY(0);
  transition: opacity 0.15s ease, transform 0.15s ease;
}

/* =====================================================
   Reading page (fullscreen)
   ===================================================== */
#displayPage{
  display:none;
  position:fixed; inset:0;
  width:100%; height:100%; overflow:hidden;
  background:var(--card);
}

/* Character area */
#charContainer{
  position:relative;
  height:calc(100dvh - 110px);
  width:100%;
  display:flex; align-items:center; justify-content:center;
  padding:12px;
}

#charDisplay{
  display:flex; justify-content:center; align-items:baseline;
  gap:.12em; white-space:nowrap; line-height:1;
  font-family:"Noto Sans SC",sans-serif; font-weight:800;
}

#charDisplay span{ display:inline-flex; width:1em; justify-content:center; align-items:center; text-align:center }
#charDisplay .han, #charDisplay .punc{ font-weight:800 }
#charDisplay.shifted{ transform:translateX(.4em) }

#pinyin,#defs{
  position:absolute; left:50%; transform:translateX(-50%);
  text-align:center; width:100%; padding:0 12px;
}
#pinyin{ top:calc(50% + 12vh); font-size:clamp(22px,6.2vw,34px); font-weight:700 }
#defs{   top:calc(50% + 18vh); font-size:clamp(16px,4.4vw,24px); font-weight:600; color:#0f172ac7 }
#pinyin, #defs{ pointer-events:none }

/* Reading controls */
:root{
  --maxWidth: 760px;
  --safe: env(safe-area-inset-bottom, 0px);
  --gap:10px; --padX:12px; --slotH1:62px; --slotH2:54px; --radius:14px;
  --blur: 10px; --elev: 0 6px 20px rgba(0,0,0,.12);
  --alpha1:.18; --alpha2:.26; --stroke:.55;
}

.bar{ position:absolute; left:50%; transform:translateX(-50%); width:100%; max-width:var(--maxWidth); padding:0 var(--padX); display:flex; gap:var(--gap); }
.bar-default{ bottom: calc(var(--safe) + 0px); }
.bar-extra{ bottom: calc(var(--safe) + var(--slotH1) + 10px); display:none; }

.slot{ 
  flex:1; display:flex; align-items:center; justify-content:center; border-radius: var(--radius);
  background: rgba(255,255,255,0.1);
  box-shadow: var(--elev);
  border:1px solid; cursor:pointer; user-select:none; height:var(--slotH1); 
}

.bar-extra .slot{ height:var(--slotH2); }
.icon{ width:24px; height:24px; display:block } .icon-sm{ width:20px; height:20px; display:block }

.arrow-cluster{
  position:absolute;
  left:50%;
  transform:translateX(-50%);
  bottom: calc(var(--safe) + var(--slotH1) + 10px);
  display:flex;
  gap:14px;
  align-items:center;
  z-index:3;
}

.arrow-btn, .arrow-collapse-top{ 
  width:36px; 
  height:26px; 
  border-radius:999px; 
  cursor:pointer; 
  border:1px solid;
  backdrop-filter: blur(var(--blur)); 
  -webkit-backdrop-filter: blur(var(--blur)); 
  box-shadow: var(--elev);
  display: flex;
  align-items: center;
  justify-content: center;
  line-height: 0;
  padding: 0;
  margin: 0;
  position: relative;
}

.arrow-collapse-top{ 
  position:absolute; 
  left:50%; 
  transform:translateX(-50%); 
  bottom: calc(var(--safe) + var(--slotH1) + 10px + var(--slotH2) + 8px); 
  display:none; 
  z-index: 4;
}

.arrow-btn svg,
.arrow-collapse-top svg{
  display: block;
  width: 18px;
  height: 18px;
  margin: 0;
  position: absolute;
  top: 50%;
  left: 50%;
  transform: translate(-50%, -50%);
}

.arrow-collapse-top svg {
  transform: translate(-50%, -50%) rotate(180deg);
}

.arrow-cluster #arrowToggle svg {
  position: absolute !important;
  top: 50% !important;
  left: 48% !important;
  transform: translate(-50%, -50%) !important;
  width: 18px !important;
  height: 18px !important;
  display: block !important;
  margin: 0 !important;
}

.arrow-cluster #arrowHide svg {
  position: absolute !important;
  top: 50% !important;
  left: 48% !important;
  transform: translate(-50%, -50%) rotate(180deg) !important;
  width: 18px !important;
  height: 18px !important;
  display: block !important;
  margin: 0 !important;
}

.bottom-hit{ 
  position:absolute; 
  left:0; 
  right:0; 
  bottom:0; 
  height:72px; 
  display:none; 
  cursor:pointer; 
  z-index:2; 
}

.onLightBorder{ border-color: rgba(0,0,0,var(--stroke)); }
.onDarkBorder { border-color: rgba(255,255,255,var(--stroke)); }
.defOnLight { background: rgba(0,0,0,var(--alpha1)); color:#000; }
.defOnDark  { background: rgba(255,255,255,var(--alpha1)); color:#fff; }
.extOnLight { background: rgba(0,0,0,var(--alpha2)); color:#000; }
.extOnDark  { background: rgba(255,255,255,var(--alpha2)); color:#fff; }

.overlay-footer {
  flex-shrink: 0;
  display: flex;
  justify-content: flex-end;
  gap: 12px;
  padding: 12px 16px;
  border-top: 1px solid #e5e7eb;
  background: #f9fafb;
}

.overlay-footer .info-btn {
  appearance: none;
  border: none;
  border-radius: 12px;
  padding: 10px 16px;
  font-weight: 700;
  cursor: pointer;
}

.overlay-footer .info-cancel {
  background: #e5e7eb;
  color: #111827;
}

.overlay-footer .info-validate {
  background: #ef4444;
  color: #ffffff;
}

#selectionOverlay {
  position: fixed;
  inset: 0;
  z-index: 1000;
  display: none;
  align-items: center;
  justify-content: center;
  background: rgba(0,0,0,.45);
}

/* Info Overlay */
#infoOverlay{
  position:fixed; inset:0; z-index:1100;
  display:none; align-items:center; justify-content:center;
  padding:16px;
  background:rgba(0,0,0,.45);
}

#infoOverlay .info-card{
  width:100%; max-width:860px; max-height:86dvh;
  border-radius:14px; box-shadow:0 10px 28px rgba(0,0,0,.26);
  display:flex; flex-direction:column; overflow:hidden;
  background:var(--info-bg,#ffffff); color:var(--info-fg,#111);
}

#infoOverlay .info-header{
  display:flex; align-items:center; justify-content:space-between;
  padding:12px 16px; font-weight:800;
  background:color-mix(in oklab, var(--info-bg,#fff) 88%, #000 0%);
  border-bottom:1px solid color-mix(in oklab, var(--info-fg,#111) 10%, transparent);
}

#infoOverlay .info-close{
  background:transparent; border:none; font-size:20px; cursor:pointer; color:inherit;
}

#infoOverlay .info-body{
  padding:14px 14px 6px; overflow:auto; line-height:1.9;
}

.info-word {
  display:inline-block;
  margin:6px 6px;
  padding:8px 12px;
  border-radius:8px;
  font-family:"Noto Sans SC","Inter",sans-serif;
  font-weight:700;
  font-size:22px;
  background:color-mix(in oklab, var(--info-bg,#fff) 85%, #000 0%);
  color: var(--info-fg,#111);
  border:1px solid color-mix(in oklab, var(--info-fg,#111) 10%, transparent);
  user-select:none;
}

.info-word.selectable{ 
  cursor: pointer !important;
  pointer-events: auto !important; 
}

.info-word.current{
  outline: 2px solid color-mix(in oklab, var(--info-fg, #111) 40%, transparent);
  outline-offset: 2px; 
}

.info-word.chosen {
  background: #ef4444;
  color: #ffffff;
  border-color: rgba(255,255,255,0.25);
}

.info-word.initialSelected {
  color: #dc2626 !important;
  background: inherit;
  border: inherit;
}

#infoOverlay .info-footer{
  display:flex; gap:12px; justify-content:flex-end; padding:12px 16px;
  border-top:1px solid color-mix(in oklab, var(--info-fg,#111) 10%, transparent);
  background:color-mix(in oklab, var(--info-bg,#fff) 92%, #000 0%);
}

.info-btn{
  appearance:none; border:none; border-radius:12px; padding:12px 18px;
  font-weight:800; cursor:pointer;
}

.info-btn.info-cancel{
  background: color-mix(in oklab, var(--info-fg,#111) 10%, transparent);
  color: var(--info-fg,#111);
}

.info-btn.info-validate {
  background: #ef4444;
  color: #ffffff;
}

.info-word.initialSelected.chosen,
#segmentedOverlayText span.selected.initialSelected {
  background: #ef4444;
  color: #ffffff !important;
  border-color: rgba(255,255,255,0.25);
}

#hamburger {
  position: absolute;
  bottom: calc(env(safe-area-inset-bottom, 0px) + var(--slotH1) + 6px);
  right: var(--padX);
  transform: translateX(-50%);
  background: none;
  border: none;
  box-shadow: none;
  width: auto;
  height: auto;
  padding: 0;
}

#hamburger svg {
  width: 24px;
  height: 24px;
  fill: currentColor;
}

/* Game bars */
#gameBars {
  position: absolute;
  left: 50%;
  transform: translateX(-50%);
  bottom: calc(env(safe-area-inset-bottom, 0px) + 0px);
  width: 100%;
  max-width: 760px;
  padding: 0 12px;
  z-index: 2;
}

.game-bar {
  display: grid;
  grid-template-columns: 1fr 2fr 2fr 2fr 1fr;
  gap: 10px;
  height: 62px;
}

.game-btn {
  display: flex;
  align-items: center;
  justify-content: center;
  border-radius: 14px;
  border: none !important;
  backdrop-filter: saturate(120%) blur(10px);
  -webkit-backdrop-filter: saturate(120%) blur(10px);
  box-shadow: 0 6px 20px rgba(0,0,0,.12);
  cursor: pointer;
  transition: transform 0.1s ease;
}

.game-btn:active {
  transform: scale(0.98);
}

.game-btn .icon {
  width: 24px;
  height: 24px;
  display: block;
}

.game-btn#quitGameBtn {
  background: rgba(220, 38, 38, 0.2);
  color: #991b1b;
  border-color: rgba(220, 38, 38, 0.4);
}

.game-btn#prevSentenceBtn {
  background: rgba(59, 130, 246, 0.2);
  color: #1e40af;
  border-color: rgba(59, 130, 246, 0.4);
}

.game-btn#playGameBtn {
  background: rgba(34, 197, 94, 0.2);
  color: #166534;
  border-color: rgba(34, 197, 94, 0.4);
}

.game-btn#nextSentenceBtn {
  background: rgba(249, 115, 22, 0.2);
  color: #9a3412;
  border-color: rgba(249, 115, 22, 0.4);
}

.game-btn#showGameBtn {
  background: rgba(168, 85, 247, 0.2);
  color: #6b21a8;
  border-color: rgba(168, 85, 247, 0.4);
}

.game-btn#randomSentenceBtn {
  background: rgba(236, 72, 153, 0.2);
  color: #9f1239;
  border-color: rgba(236, 72, 153, 0.4);
}


.mode-switch.active {
  background: #ef4444 !important;
  color: white !important;
  border-color: #ef4444 !important;
}

.nav-btn-replay {
  background: rgba(34, 197, 94, 0.85);
  color: #ffffff;
  font-weight: 700;
  border: none !important;
}

.nav-btn-replay::before {
  content: 'â¶';
  margin-right: 6px;
  font-size: 12px;
}

.nav-btn-replay:hover {
  background: rgba(34, 197, 94, 0.95);
  transform: translateY(-1px);
}

/* Game overlays */
#gameModeOverlay,
#gamePlayOverlay {
  position: fixed;
  inset: 0;
  z-index: 1200;
  display: flex;
  align-items: center;
  justify-content: center;
  background: rgba(0,0,0,0.5);
  padding: 16px;
}

.game-overlay-content {
  width: 100%;
  max-width: 600px;
  max-height: 90vh;
  border-radius: 16px;
  overflow: hidden;
  box-shadow: 0 20px 50px rgba(0,0,0,0.3);
  display: flex;
  flex-direction: column;
}

.game-header {
  display: flex;
  justify-content: space-between;
  align-items: center;
  padding: 16px 20px;
  border-bottom: 1px solid rgba(0,0,0,0.1);
  background: rgba(0,0,0,0.05);
}

.game-header h3 {
  margin: 0;
  font-size: 18px;
  font-weight: 800;
}

.close-btn {
  background: none;
  border: none;
  font-size: 20px;
  cursor: pointer;
  color: inherit;
  padding: 4px;
}

.mode-buttons {
  display: flex;
  gap: 16px;
  justify-content: center;
  padding: 24px;
}

.mode-btn {
  background: rgba(239, 68, 68, 0.15);
  border: 2px solid rgba(239, 68, 68, 0.3);
  border-radius: 12px;
  padding: 16px 24px;
  font-size: 16px;
  font-weight: 700;
  cursor: pointer;
  transition: all 0.2s ease;
  color: #1f2937;
}

.mode-btn:hover {
  background: rgba(239, 68, 68, 0.25);
  border-color: rgba(239, 68, 68, 0.4);
  transform: translateY(-2px);
  box-shadow: 0 8px 20px rgba(239, 68, 68, 0.2);
}

.mode-switcher {
  display: flex;
  gap: 8px;
}

.mode-switcher .mode-switch {
  background: rgba(0,0,0,0.08);
  border: 2px solid rgba(0,0,0,0.2);
  border-radius: 10px;
  padding: 10px 20px;
  font-size: 15px;
  font-weight: 700;
  cursor: pointer;
  color: #1f2937;
  transition: all 0.2s ease;
  box-shadow: 0 2px 8px rgba(0,0,0,0.08);
}

.mode-switcher .mode-switch.active {
  background: #ef4444;
  color: white;
  border-color: #ef4444;
  box-shadow: 0 4px 12px rgba(239, 68, 68, 0.3);
  transform: translateY(-1px);
}

.mode-switcher .mode-switch:hover:not(.active) {
  background: rgba(0,0,0,0.12);
  border-color: rgba(0,0,0,0.3);
  transform: translateY(-1px);
}

.game-content {
  padding: 20px;
  flex: 1;
  overflow-y: auto;
}

.word-pool,
.sentence-builder {
  margin-bottom: 20px;
}

.pool-title {
  font-weight: 700;
  margin-bottom: 8px;
  color: inherit;
}

.words-container {
  min-height: 60px;
  padding: 12px;
  border: 2px dashed rgba(0,0,0,0.3);
  border-radius: 8px;
  display: flex;
  flex-wrap: wrap;
  gap: 8px;
  background: rgba(0,0,0,0.05);
}

.drop-zone {
  background: rgba(0,0,0,0.1);
}

.word-token {
  background: rgba(239, 68, 68, 0.15);
  border: 2px solid rgba(239, 68, 68, 0.3);
  border-radius: 8px;
  padding: 12px 16px;
  font-size: 22px;
  font-weight: 700;
  cursor: pointer;
  user-select: none;
  transition: all 0.2s ease;
  color: #000000;
  font-family: "Noto Sans SC", "Inter", sans-serif;
}

.word-token:hover {
  transform: translateY(-1px);
  box-shadow: 0 4px 12px rgba(0,0,0,0.15);
}

.word-token.dragging {
  opacity: 0.5;
  transform: rotate(2deg);
}


/* Le reste du CSS continue aprÃ¨s */
.free-input-container {
  margin-bottom: 20px;
}
.free-input-container {
  margin-bottom: 20px;
}

.free-input-container label {
  display: block;
  font-weight: 700;
  margin-bottom: 8px;
  color: inherit;
}

.free-textarea {
  width: 100%;
  min-height: 120px;
  padding: 16px;
  border: 2px solid rgba(0,0,0,0.2);
  border-radius: 8px;
  font-size: 16px;
  font-family: "Noto Sans SC", "Inter", sans-serif;
  background: rgba(0,0,0,0.05);
  color: inherit;
  resize: vertical;
}

.free-textarea:focus {
  outline: none;
  border-color: #ef4444;
  box-shadow: 0 0 0 3px rgba(239, 68, 68, 0.2);
}

.validate-btn,
.retry-btn {
  background: #ef4444;
  color: white;
  border: none;
  border-radius: 8px;
  padding: 12px 24px;
  font-size: 16px;
  font-weight: 700;
  cursor: pointer;
  display: block;
  margin: 0 auto 16px;
  transition: all 0.2s ease;
}

.validate-btn:hover,
.retry-btn:hover {
  background: #dc2626;
  transform: translateY(-1px);
}

.retry-btn {
  background: #6b7280;
}

.retry-btn:hover {
  background: #4b5563;
}

.result-message {
  text-align: center;
  padding: 16px;
  margin: 16px 0;
  border-radius: 8px;
  font-weight: 700;
  font-size: 16px;
}

.result-message.success {
  background: rgba(34, 197, 94, 0.2);
  color: #000000;
  border: 1px solid rgba(34, 197, 94, 0.4);
}

.result-message.error {
  background: rgba(239, 68, 68, 0.2);
  color: #991b1b;
  border: 1px solid rgba(239, 68, 68, 0.4);
}

.game-nav-footer {
  display: flex;
  justify-content: space-between;
  gap: 12px;
  padding: 16px 20px;
  border-top: 1px solid rgba(0,0,0,0.1);
  background: rgba(0,0,0,0.05);
}

.nav-btn {
  background: rgba(0,0,0,0.1);
  border: 1px solid rgba(0,0,0,0.2);
  border-radius: 8px;
  padding: 10px 16px;
  font-size: 14px;
  font-weight: 600;
  cursor: pointer;
  color: inherit;
  transition: all 0.2s ease;
}

.nav-btn:hover {
  background: rgba(0,0,0,0.2);
}

.nav-btn:disabled {
  opacity: 0.5;
  cursor: not-allowed;
}

.game-mode-active .bar.bar-default {
  display: none !important;
}

.game-mode-active #ghostBar {
  display: none !important;
}

.bar.bar-default{
  position:absolute; left:50%; transform:translateX(-50%);
  bottom: calc(env(safe-area-inset-bottom, 0px) + 0px);
  width:100%; max-width:760px; padding:0 12px;
  display:grid; grid-template-columns: 1fr 2fr 2fr 2fr 1fr auto; gap: 10px;
}

.bar.bar-default .slot{
  height: 62px;
  display:flex; align-items:center; justify-content:center;
  border-radius:14px; border:1px solid;
  backdrop-filter: saturate(120%) blur(10px); -webkit-backdrop-filter: saturate(120%) blur(10px);
  box-shadow: 0 6px 20px rgba(0,0,0,.12);
}

.bar.bar-default .slot,
#hamburger {
  border: none !important;
  outline: none !important;
}

.bar.bar-default .icon{ width:24px; height:24px; display:block }

#ghostBar{
  position:absolute;
  left:50%;
  transform:translateX(-50%);
  bottom: calc(env(safe-area-inset-bottom, 0px) + 0px);
  width:100%;
  max-width:760px;
  padding:0 12px;
  display:none;
  grid-template-columns: 1fr 1fr 1fr;
  gap:10px;
  background:transparent;
  z-index:3;
}

#ghostBar button{
  height:62px;
  background:transparent;
  border:none;
  pointer-events:auto;
}

/* Cacher la barre de boutons quand l'overlay de jeu est ouvert */
body:has(#gamePlayOverlay[style*="display: flex"]) #gameBarsNoRead,
body:has(#gamePlayOverlay[style*="display: flex"]) #gameBars {
  display: none !important;
}

#hamburger{
  width:36px; height:36px;
  border-radius:999px; border:1px solid;
  display:flex; align-items:center; justify-content:center;
  background: transparent;
  box-shadow: 0 6px 20px rgba(0,0,0,.12);
}

.onLightBorder{ border-color: rgba(0,0,0,.55); }
.onDarkBorder { border-color: rgba(255,255,255,.55); }
.defOnLight { background: rgba(0,0,0,.18); color:#000; }
.defOnDark  { background: rgba(255,255,255,.18); color:#fff; }

/* === Mobile DnD only === */
@media (pointer: coarse) and (hover: none) {
  .words-container { position: relative; }
  .word-token { touch-action: none; } /* permet le suivi du doigt */
  .word-token.drag-source { visibility: hidden; }

  .drag-ghost {
    position: fixed;
    z-index: 10000;
    pointer-events: none;
    transform: translate(-50%, -50%) scale(0.96); /* petit scale pour voir derriÃ¨re */
    opacity: .95;
    filter: drop-shadow(0 6px 18px rgba(0,0,0,.25));
    will-change: transform, left, top;
  }

  .placeholder-token {
    display: inline-block;
    min-width: 28px;
    border-radius: 10px;
    background: rgba(16,185,129,.14);   /* vert clair */
    border: 2px dashed rgba(16,185,129,.6);
    vertical-align: middle;
  }

  .drop-caret {
    position: fixed;
    z-index: 10001;
    width: 2px;
    background: #10B981; /* vert */
    border-radius: 1px;
  }

  /* feedback de zone cible */
  .words-container.drop-zone--active {
    border-color: rgba(59,130,246,.6);
    box-shadow: 0 0 0 3px rgba(59,130,246,.15) inset;
  }
}


@media (max-width:560px){
  :root{ --slotH1:58px; --slotH2:50px; --gap:8px; --padX:10px; }
}

@media (max-width:600px){
  .container{
    padding:max(10px, env(safe-area-inset-left)) max(10px, env(safe-area-inset-right));
  }
  .card{ padding:calc(var(--space) * .9) }
  .opt{ gap:14px }
  .swatch{ min-width:130px }
  .cta-bar .btn-primary{ width:100% }

  #controls .ctrl-btn{ width:56px; height:56px; font-size:26px }

  #charContainer{ height:calc(100dvh - 110px) }
  #charDisplay{ font-size:80px }
  #charDisplay.long-seq{ font-size:clamp(28px, 6vw, 40px) }

  #pinyin{ top:calc(50% + 8vh) }
  #defs{   top:calc(50% + 12vh) }
  
  .mode-buttons {
    flex-direction: column;
    align-items: center;
  }
  
  .mode-btn {
    width: 100%;
    max-width: 280px;
  }
  
  .game-nav-footer {
    flex-direction: column;
  }
  
  .game-bar {
    height: 54px;
  }
  
  .game-btn {
    font-size: 13px;
  }
  
  .mode-option {
    flex: 1 1 100%;
    max-width: none;
  }
  
  .mode-selector {
    flex-direction: column;
  }
}
</style>
</head>

<body>
  <div class="container">
    <div class="card" id="homePage">
      <h1>Lecteur chinois mot-Ã -mot</h1>

      <!-- Mode Selector -->
      <div class="mode-selector">
        <div class="mode-option">
          <input type="radio" id="readMode" name="appMode" value="read" checked>
          <label class="mode-label" for="readMode">
            <div class="mode-icon">ð</div>
            <div class="mode-title">Mode Lecture</div>
            <div class="mode-desc">Lecture avec sÃ©lection de mots</div>
          </label>
        </div>
        <div class="mode-option">
          <input type="radio" id="gameMode" name="appMode" value="game">
          <label class="mode-label" for="gameMode">
            <div class="mode-icon">ð®</div>
            <div class="mode-title">Mode Jeu</div>
            <div class="mode-desc">Exercices interactifs</div>
          </label>
        </div>
      </div>

      <div class="input-wrap">
        <div id="editorArea">
          <textarea id="inputText">ä½ å¥½ï¼æä»¬æ¯å­¦çãèå¸åæ¬¢ä¸­å½ã</textarea>
        </div>
        <div id="segmentedArea" style="display:none;">
          <div id="segmentedText" class="segmented-box"></div>
        </div>
        <div class="editor-actions">
          <button id="clearText" class="editor-btn" title="Effacer le texte">
            <svg viewBox="0 0 24 24" class="icon" xmlns="http://www.w3.org/2000/svg">
              <line x1="18" y1="6" x2="6" y2="18" stroke-width="2" stroke-linecap="round"/>
              <line x1="6" y1="6" x2="18" y2="18" stroke-width="2" stroke-linecap="round"/>
            </svg>
          </button>
          <button id="toggleEdit" class="editor-btn" title="Basculer Ã©dition/segmentation" style="display:none;">
            <svg viewBox="0 0 24 24" class="icon" xmlns="http://www.w3.org/2000/svg">
              <path d="M3 17.25V21h3.75L17.81 9.94l-3.75-3.75L3 17.25z"/>
              <path d="M20.71 7.04a1.003 1.003 0 0 0 0-1.42l-2.34-2.34a1.003 
                       1.003 0 0 0-1.42 0l-1.83 1.83 3.75 3.75 1.84-1.82z"/>
            </svg>
          </button>
        </div>
      </div>

      <!-- Game Mode Options -->
      <div class="game-mode-options" id="gameModeOptions">
        <div class="game-mode-title">Options du mode jeu :</div>
        <div class="game-mode-grid">
  <div class="game-mode-item">
    <input type="radio" id="gameBoth" name="gameType" value="both" checked>
    <label for="gameBoth">Normal</label>
  </div>
  <div class="game-mode-item">
    <input type="radio" id="gameReorderNoRead" name="gameType" value="reorderNoRead">
    <label for="gameReorderNoRead">Phrases alÃ©atoires</label>
  </div>
</div>
      </div>

      <fieldset>
        <legend>ParamÃ¨tres de lecture</legend>
        <div>
          <label>Vitesse (mots/min) : <strong id="speedLabel">120</strong></label>
          <input class="range" type="range" id="speed" min="30" max="360" step="10" value="120">
        </div>
        <div class="opt" id="pinyinOption">
          <input type="checkbox" id="showPinyin"><span>Afficher le pinyin</span>
        </div>
        <div class="opt" id="translationOption">
          <input type="checkbox" id="showDefs"><span>Afficher la traduction</span>
        </div>
        <div class="opt" id="selectionOption">
          <input type="checkbox" id="alwaysShowSelected">
          <span>Tout afficher sur la sÃ©lection</span>
        </div>
      </fieldset>

      <fieldset>
        <legend>Couleurs</legend>
        <div class="color-row">
          <div class="swatch">
            <div id="bgColorPicker"></div>
            <label for="bgColorPicker">Fond</label>
          </div>
          <div class="swatch">
            <div id="textColorPicker"></div>
            <label for="textColorPicker">Mots</label>
          </div>
          <div class="swatch" id="highlightBgSwatch">
            <div id="highlightBgColorPicker"></div>
            <label for="highlightBgColorPicker">Fond 2</label>
          </div>
          <div class="swatch" id="highlightColorSwatch">
            <div id="highlightColorPicker"></div>
            <label for="highlightColorPicker">Mots 2</label>
          </div>
        </div>
      </fieldset>

      <fieldset>
        <legend>Dictionnaire</legend>
        <button class="btn-ghost" id="loadDict">Charger CC-CEDICT</button>
        <input type="file" id="dictFile" accept=".u8,.txt" style="display:none">
        <span id="dictStatus" style="margin-left:8px;color:var(--muted)">Aucun dictionnaire chargÃ©</span>
      </fieldset>

      <div class="cta-bar">
        <button class="btn-primary" id="startBtn">â¶ DÃ©marrer la lecture</button>
      </div>
    </div>
  </div>

  <!-- Selection Overlay -->
  <div id="selectionOverlay">
    <div class="overlay-content">
      <div id="overlayHeader">
        <button id="closeOverlay" aria-label="Fermer la sÃ©lection">â</button>
      </div>
      <div id="segmentedOverlayText"></div>
      <div class="overlay-footer">
        <button id="overlayCancelBtn" class="info-btn info-cancel">Annuler</button>
        <button id="overlayValidateBtn" class="info-btn info-validate">Valider</button>
      </div>
    </div>
  </div>
  
  <!-- Info Overlay -->
  <div id="infoOverlay" style="display:none">
    <div class="info-card">
      <div class="info-header">
        <strong>AperÃ§u du texte</strong>
        <button class="info-close" id="infoCloseBtn" aria-label="Fermer">â</button>
      </div>
      <div class="info-body" id="infoWords"></div>
      <div class="info-footer">
        <button class="info-btn info-cancel" id="infoCancelBtn">Annuler</button>
        <button class="info-btn info-validate" id="infoValidateBtn">Valider</button>
      </div>
    </div>
  </div>

  <!-- Display Page -->
  <div id="displayPage">
    <div id="charContainer">
      <div id="charDisplay"></div>
      <div id="pinyin"></div>
      <div id="defs"></div>
    </div>

    <!-- Normal Bar -->
    <div class="bar bar-default" id="barDefault" aria-label="Menu de base">
      <button class="slot slot-quit" id="quitBtn" title="Quitter" aria-label="Quitter">
        <svg class="icon" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round">
          <line x1="18" y1="6" x2="6" y2="18"></line>
          <line x1="6"  y1="6" x2="18" y2="18"></line>
        </svg>
      </button>
      <button class="slot slot-prev" id="prevWordBtn" title="Mot prÃ©cÃ©dent" aria-label="Mot prÃ©cÃ©dent">
        <svg class="icon" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round">
          <polyline points="15 18 9 12 15 6"></polyline>
        </svg>
      </button>
      <button class="slot slot-play" id="pauseBtn" title="Lecture/Pause" aria-label="Lecture/Pause">
        <svg id="pauseIcon" class="icon" viewBox="0 0 24 24" fill="currentColor">
          <polygon points="8,6 18,12 8,18"></polygon>
        </svg>
      </button>
      <button class="slot slot-next" id="nextWordBtn" title="Mot suivant" aria-label="Mot suivant">
        <svg class="icon" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round">
          <polyline points="9 18 15 12 9 6"></polyline>
        </svg>
      </button>
      <button class="slot slot-info" id="infoBtn" title="Infos" aria-label="Infos">
        <svg class="icon" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round">
          <line x1="12" y1="17" x2="12" y2="11"></line>
          <line x1="12" y1="7"  x2="12" y2="7"></line>
        </svg>
      </button>
      <button class="slot slot-hamburger" id="hamburger" title="Afficher/Masquer le menu">
        <svg class="icon" viewBox="0 0 24 24" fill="currentColor">
          <path d="M4 7h16v2H4zm0 5h16v2H4zm0 5h16v2H4z"/>
        </svg>
      </button>
    </div>

    <!-- Ghost Bar -->
    <div id="ghostBar" aria-hidden="true" inert>
      <button id="ghostPrev"  aria-label="Mot prÃ©cÃ©dent"></button>
      <button id="ghostPause" aria-label="Lecture/Pause"></button>
      <button id="ghostNext"  aria-label="Mot suivant"></button>
    </div>

    <!-- Game Bars -->
    <div id="gameBars" style="display:none;">
      <div class="game-bar">
        <button class="game-btn" id="quitGameBtn" title="Quitter le mode jeu" aria-label="Quitter">
          <svg class="icon" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round">
            <line x1="18" y1="6" x2="6" y2="18"></line>
            <line x1="6"  y1="6" x2="18" y2="18"></line>
          </svg>
        </button>
        <button class="game-btn" id="prevSentenceBtn" title="Phrase prÃ©cÃ©dente" aria-label="Phrase prÃ©cÃ©dente">
          <svg class="icon" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round">
            <polyline points="15 18 9 12 15 6"></polyline>
          </svg>
        </button>
        <button class="game-btn" id="playGameBtn" title="Lire la phrase" aria-label="Lecture">
          <svg class="icon" viewBox="0 0 24 24" fill="currentColor">
            <polygon points="8,6 18,12 8,18"></polygon>
          </svg>
        </button>
        <button class="game-btn" id="nextSentenceBtn" title="Phrase suivante" aria-label="Phrase suivante">
          <svg class="icon" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round">
            <polyline points="9 18 15 12 9 6"></polyline>
          </svg>
        </button>
        <button class="game-btn" id="showGameBtn" title="Afficher le jeu" aria-label="Jeu">
          <svg class="icon" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round">
            <line x1="12" y1="17" x2="12" y2="11"></line>
            <line x1="12" y1="7"  x2="12" y2="7"></line>
          </svg>
        </button>
      </div>
    </div>

    <!-- Game Bars No Read -->
    <div id="gameBarsNoRead" style="display:none;">
      <div class="game-bar">
        <button class="game-btn" id="quitGameNoReadBtn" title="Quitter le mode jeu" aria-label="Quitter">
          <svg class="icon" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round">
            <line x1="18" y1="6" x2="6" y2="18"></line>
            <line x1="6"  y1="6" x2="18" y2="18"></line>
          </svg>
        </button>
        <button class="game-btn" id="prevSentenceNoReadBtn" title="Phrase prÃ©cÃ©dente" aria-label="Phrase prÃ©cÃ©dente">
          <svg class="icon" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round">
            <polyline points="15 18 9 12 15 6"></polyline>
          </svg>
        </button>
        <button class="game-btn" id="randomSentenceBtn" title="Phrase alÃ©atoire" aria-label="AlÃ©atoire">
          <svg class="icon" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round">
            <path d="M16 3h5v5M4 20L21 3M21 16v5h-5M15 15l6 6M4 4l5 5"/>
          </svg>
        </button>
        <button class="game-btn" id="nextSentenceNoReadBtn" title="Phrase suivante" aria-label="Phrase suivante">
          <svg class="icon" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round">
            <polyline points="9 18 15 12 9 6"></polyline>
          </svg>
        </button>
        <button class="game-btn" id="showGameNoReadBtn" title="Afficher le jeu" aria-label="Jeu">
          <svg class="icon" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round">
            <line x1="12" y1="17" x2="12" y2="11"></line>
            <line x1="12" y1="7"  x2="12" y2="7"></line>
          </svg>
        </button>
      </div>
    </div>
  </div>

  <!-- Game Mode Overlay -->
  <div id="gameModeOverlay" style="display:none;">
    <div class="game-overlay-content">
      <div class="game-header">
        <h3>Choisissez votre mode</h3>
        <button id="closeGameMode" class="close-btn">â</button>
      </div>
      <div class="mode-buttons">
        <button id="reorderModeBtn" class="mode-btn">RÃ©organiser</button>
        <button id="freeModeBtn" class="mode-btn">Libre</button>
      </div>
      <div class="game-nav-footer">
        <button id="prevSentenceGame" class="nav-btn">â PrÃ©cÃ©dente</button>
        <button id="replayGame" class="nav-btn nav-btn-replay">Relire</button>
        <button id="nextSentenceGame" class="nav-btn">Suivante â</button>
      </div>
    </div>
  </div>

  <!-- Game Play Overlay -->
  <div id="gamePlayOverlay" style="display:none;">
    <div class="game-overlay-content">
      <div class="game-header">
        <div class="mode-switcher">
          <button id="switchReorder" class="mode-switch mode-switch-reorder active">RÃ©organiser</button>
          <button id="switchFree" class="mode-switch mode-switch-free">Libre</button>
        </div>
        <button id="closeGamePlay" class="close-btn">â</button>
      </div>
      
      <div id="reorderGame" class="game-content">
        <div id="wordPool" class="word-pool">
          <div class="pool-title">Mots disponibles :</div>
          <div id="availableWords" class="words-container"></div>
        </div>
        <div id="sentenceBuilder" class="sentence-builder">
          <div class="pool-title">Votre phrase :</div>
          <div id="userSentence" class="words-container drop-zone"></div>
        </div>
        <button id="validateReorder" class="validate-btn">Valider</button>
        <div id="reorderResult" class="result-message" style="display:none;"></div>
        <button id="retryReorder" class="retry-btn" style="display:none;">Recommencer</button>
      </div>
      
      <div id="freeGame" class="game-content" style="display:none;">
        <div class="free-input-container">
          <label for="freeTextInput">Retapez la phrase :</label>
          <textarea id="freeTextInput" class="free-textarea" placeholder="Tapez la phrase ici..."></textarea>
        </div>
        <button id="validateFree" class="validate-btn">Valider</button>
        <div id="freeResult" class="result-message" style="display:none;"></div>
        <button id="retryFree" class="retry-btn" style="display:none;">Recommencer</button>
      </div>
      
      <div class="game-nav-footer">
        <button id="prevSentenceInGame" class="nav-btn">â PrÃ©cÃ©dente</button>
        <button id="replayInGame" class="nav-btn nav-btn-replay">Relire</button>
        <button id="nextSentenceInGame" class="nav-btn">Suivante â</button>
      </div>
    </div>
  </div>

<script>
// ========= Ãtat global =========
let dict = { entries: new Map(), wordSet: new Set(), maxLen: 1 };
let tokens = [];
let idx = 0;
let timer = null;
let playing = false;
let highlightWords = [];
let readModeHighlightWords = [];  // Pour le mode lecture
let gameModeHighlightWords = [];  // Pour le mode jeu (si besoin)
let currentToken = null;
let editMode = true;
let infoChosenIndex = null;
let infoWasPlaying  = false;
let __menuHiddenByUser = false;
let gameMode = false;
let gameType = 'both';
let sentenceStarts = [];
let currentSentenceIndex = 0;
let originalSentence = '';
let currentGameMode = 'reorder';
let appMode = 'read';
let playedSentences = [];  // Pour tracker les phrases dÃ©jÃ  jouÃ©es


// ========= Utilitaires =========
function numericToDiacriticPinyin(pinyin){
  const toneMarks={a:['Ä','Ã¡','Ç','Ã '],e:['Ä','Ã©','Ä','Ã¨'],i:['Ä«','Ã­','Ç','Ã¬'],o:['Å','Ã³','Ç','Ã²'],u:['Å«','Ãº','Ç','Ã¹'],Ã¼:['Ç','Ç','Ç','Ç']};
  function applyMark(s,tIndex){
    for(const l of ['a','o','e']){const i=s.toLowerCase().indexOf(l); if(i!==-1) return s.slice(0,i)+toneMarks[l][tIndex]+s.slice(i+1);}
    for(let i=s.length-1;i>=0;i--){const c=s[i].toLowerCase(); if(toneMarks[c]) return s.slice(0,i)+toneMarks[c][tIndex]+s.slice(i+1);}
    return s;
  }
  const normalized=pinyin.replace(/u:/g,'Ã¼').replace(/U:/g,'Ã').replace(/\bv/g,'Ã¼').replace(/\bV/g,'Ã');
  return normalized.replace(/([A-Za-zÃ¼:]+)([0-5])/g,(m,sy,t)=>{const tone=+t; if(tone===0||tone===5) return sy.replace(/:/g,''); return applyMark(sy,tone-1);});
}

function normalizeChineseText(text){
  if(!text) return '';
  text = text.replace(/[\u200B-\u200D\uFEFF]/g,'');
  text = text.replace(/\r\n/g, '\n').replace(/\r/g, '\n');
  text = text.replace(/\n+/g, ' ');
  text = text.replace(/([\p{Script=Han}])\p{White_Space}+(?=[\p{Script=Han}])/gu,'$1');
  text = text
    .replace(/\p{White_Space}+([ï¼ãï¼ï¼ãï¼ï¼,.!?;"ãã])/gu,'$1')
    .replace(/([ï¼ãï¼ï¼ãï¼ï¼,.!?;"ãã])\p{White_Space}+/gu,'$1');
  return text.trim();
}

function parseCedict(raw){
  const entries=new Map(), wordSet=new Set(); let maxLen=1;
  for(const line of raw.split(/\r?\n/)){
    const L=line.trim(); if(!L||L.startsWith("#")) continue;
    const m=L.match(/^(\S+)\s+(\S+)\s+\[([^\]]+)\]\s+\/(.+)\/$/); if(!m) continue;
    const simp=m[2], pinyin=numericToDiacriticPinyin(m[3]), defs=m[4].split("/").map(d=>numericToDiacriticPinyin(d.trim())).filter(Boolean);
    if(!entries.has(simp)) entries.set(simp,{simp, pinyin, defs});
    wordSet.add(simp); if(simp.length>maxLen) maxLen=simp.length;
  }
  return { entries, wordSet, maxLen };
}

const isHan = ch => /[\u3400-\u9FFF\uF900-\uFAFF]/.test(ch);

function segmentText(text, wordSet, maxLen){
  const OPEN  = /["'Â«ãããï¼(ã]/u;
  const CLOSE = /["'Â»ãããï¼)ã]/u;
  const PUNC  = /[ï¼ãï¼ï¼ãï¼ï¼,.!?;â¦â\-Â·â¢â¥ï¼ï¼]/u;

  const isOpen   = ch => OPEN.test(ch);
  const isAfter  = ch => CLOSE.test(ch) || PUNC.test(ch);

  const result = [];
  let i = 0;
  let prefix = "";

  while (i < text.length){
    let ch = text[i];
    if (/\s/.test(ch)) { i++; continue; }
    if (isOpen(ch)) { prefix += ch; i++; continue; }

    let match = null;
    let len = Math.min(maxLen, text.length - i);
    while (len > 0){
      const cand = text.substr(i, len);
      if (wordSet.has(cand)) { match = cand; break; }
      len--;
    }

    if (match){
      result.push({ text: prefix + match, type:'han' });
      prefix = "";
      i += match.length;
      while (i < text.length && isAfter(text[i])) {
        result[result.length - 1].text += text[i];
        i++;
      }
      continue;
    }

    ch = text[i];
    if (isAfter(ch)) {
      if (result.length) result[result.length - 1].text += (prefix + ch);
      else result.push({ text: prefix + ch, type: 'punc' });
      prefix = ""; i++; continue;
    }

    result.push({ text: prefix + ch, type: /[\u3400-\u9FFF\uF900-\uFAFF]/.test(ch) ? 'han' : 'punc' });
    prefix = ""; i++;
  }

  if (prefix){
    if (result.length) result[result.length - 1].text = prefix + result[result.length - 1].text;
    else result.push({ text: prefix, type: 'punc' });
  }
  return result;
}

function attachDictInfo(tokens, dictMap){
  return tokens.map(tok=>{
    if(tok.type==='han'){
      const clean=tok.text.replace(/[ãï¼ï¼,.ï¼!?]$/,'');
      const e=dictMap.get(clean);
      if(e) return {...tok, pinyin:e.pinyin, defs:e.defs};
    }
    return tok;
  });
}

// ========= Rendu (accueil) =========
function renderSegmented(){
  const text = normalizeChineseText(document.getElementById('inputText').value);
  const segmented = attachDictInfo(segmentText(text, dict.wordSet, dict.maxLen), dict.entries);
  const c = document.getElementById('segmentedText'); 
  c.innerHTML = '';

  segmented.forEach((tok, i) => {
    const el = document.createElement('span');
    el.className = 'token';
    el.textContent = tok.text;

    const clean = tok.text.replace(/[ãï¼ï¼,.ï¼!?]$/, '');
    if (highlightWords.includes(clean)) el.classList.add('selected');

    el.addEventListener('click', (e) => {
      e.stopPropagation();
      if (highlightWords.includes(clean)) {
        highlightWords = highlightWords.filter(w => w !== clean);
      } else {
        highlightWords.push(clean);
      }
      readModeHighlightWords = [...highlightWords];  // â AJOUTER ICI
      renderSegmented();
      showToken(tok);
    });

    const play = document.createElement('button');
    play.className = 'chip-play';
    play.textContent = 'â¶';
    play.title = 'Lire Ã  partir de ce mot';
    play.addEventListener('click', (e) => {
      e.stopPropagation();
      document.getElementById('homePage').style.display = 'none';
      const dp = document.getElementById('displayPage');
      dp.style.display = 'block';
      dp.style.visibility = 'visible';
      restartFrom(i);
      forcePlay();
    });

    el.appendChild(play);
    c.appendChild(el);
  });
}

// ========= Rendu (page de jeu) =========
function showToken(token) {
  currentToken = token;

  const cd   = document.getElementById('charDisplay');
  const pEl  = document.getElementById('pinyin');
  const dEl  = document.getElementById('defs');
  const cont = document.getElementById('charContainer');

  cd.innerHTML = '';
  pEl.textContent = '';
  dEl.textContent = '';
  pEl.style.display = '';
  dEl.style.display = '';

  let han = token.text, punc = '';
  if (/[ãï¼ï¼,.ï¼!?]$/.test(token.text)) {
    han  = token.text.slice(0, -1);
    punc = token.text.slice(-1);
  }

  if (han) {
    for (const ch of han) {
      const s = document.createElement('span');
      s.className = 'han';
      s.textContent = ch;
      cd.appendChild(s);
    }
  }
  if (punc) {
    const sp = document.createElement('span');
    sp.className = 'punc';
    sp.textContent = punc;
    cd.appendChild(sp);
    cd.classList.add('shifted');
  } else {
    cd.classList.remove('shifted');
  }

  const normalBg      = (bgColorPicker?.getColor()?.toHEXA().toString())          || '#ffffff';
  const normalText    = (textColorPicker?.getColor()?.toHEXA().toString())        || '#000000';
  const highlightBg   = (highlightBgColorPicker?.getColor()?.toHEXA().toString()) || '#000000';
  const highlightText = (highlightColorPicker?.getColor()?.toHEXA().toString())   || '#ffffff';

  const clean = token.text.replace(/[ãï¼ï¼,.ï¼!?]$/, '');
  const isH   = highlightWords.includes(clean);

  const pageBg   = isH ? highlightBg   : normalBg;
  const textCol  = isH ? highlightText : normalText;
  cd.style.color = textCol;
  const dp = document.getElementById('displayPage');
  dp.style.backgroundColor = pageBg;
  applyControlsTheme(getContrastingColor(pageBg));

  const contrast = getContrastingColor(pageBg);
  pEl.style.color = contrast;
  dEl.style.color = contrast;

  if (token.pinyin) pEl.textContent = token.pinyin;
  if (token.defs)   dEl.textContent = token.defs.join(', ');

  const optShowPinyin = !!document.getElementById('showPinyin')?.checked;
  const optShowDefs   = !!document.getElementById('showDefs')?.checked;
  const alwaysShowSel = !!document.getElementById('alwaysShowSelected')?.checked;

  if (alwaysShowSel && isH) {
    pEl.style.display = '';
    dEl.style.display = '';
  } else {
    pEl.style.display = optShowPinyin ? '' : 'none';
    dEl.style.display = optShowDefs   ? '' : 'none';
  }

  const totalLen = han.length + (punc ? 1 : 0);
  if (totalLen >= 5) cd.classList.add('long-seq'); else cd.classList.remove('long-seq');
  if (typeof fitCharLine === 'function') fitCharLine();

  cont.dataset.toggled = '0';
  cont.onclick = (e) => {
    e.stopPropagation();
    const showPinyin = !!document.getElementById('showPinyin')?.checked;
    const showDefs   = !!document.getElementById('showDefs')?.checked;
    const toggled    = cont.dataset.toggled === '1';

    if (!showPinyin && !showDefs) {
      const bothHidden = (pEl.style.display === 'none' && dEl.style.display === 'none');
      pEl.style.display = bothHidden ? '' : 'none';
      dEl.style.display = bothHidden ? '' : 'none';
      cont.dataset.toggled = bothHidden ? '1' : '0';
      return;
    }

    if (!toggled) {
      if (showPinyin && !showDefs) {
        dEl.style.display = '';
      } else if (!showPinyin && showDefs) {
        pEl.style.display = '';
      } else {
        pEl.style.display = 'none';
        dEl.style.display = 'none';
      }
      cont.dataset.toggled = '1';
    } else {
      pEl.style.display = showPinyin ? '' : 'none';
      dEl.style.display = showDefs   ? '' : 'none';
      cont.dataset.toggled = '0';
    }
  };

  // Gestion barres jeu
  if (gameMode) {
    if (gameType === 'reorderNoRead') {
      toggleGameBarsNoRead(true);
    } else {
      toggleGameBars(true);
    }
    const gameBars = document.getElementById(gameType === 'reorderNoRead' ? 'gameBarsNoRead' : 'gameBars');
    if (gameBars) {
      gameBars.querySelectorAll('.game-btn').forEach(btn => {
        btn.style.color = contrast;
        btn.style.borderColor = 'none';
        btn.style.background = contrast === '#ffffff' 
          ? 'rgba(255,255,255,0.18)' 
          : 'rgba(0,0,0,0.18)';
      });
    }
  } else {
    toggleGameBars(false);
    toggleGameBarsNoRead(false);
  }
  
  try { enforceMenuState(); } catch (_) {}
}

function applyControlsTheme(contrastColor){
  const isDarkBg = (contrastColor === '#ffffff');
  const elemColor = isDarkBg ? '#ffffff' : '#000000';
  const borderColor = isDarkBg ? 'rgba(255,255,255,0.3)' : 'rgba(0,0,0,0.3)';

  const barDefault = document.getElementById('barDefault');
  if (barDefault) {
    barDefault.querySelectorAll('.slot, #hamburger').forEach(slot => {
      slot.style.color = elemColor;
      slot.style.borderColor = borderColor;
    });
  }
}

// ========= Page de lecture =========
function startDisplay() {
  const text = normalizeChineseText(document.getElementById('inputText').value);
  tokens = attachDictInfo(segmentText(text, dict.wordSet, dict.maxLen), dict.entries);
  idx = 0;

  if (!tokens.length) {
    alert("Aucun mot Ã  afficher.");
    return;
  }

  if (gameMode && gameType === 'reorderNoRead') {
    // Mode spÃ©cial : ne pas afficher la page de lecture du tout
    document.getElementById('homePage').style.display = 'none';
    
    sentenceStarts = computeSentenceStarts(tokens);
    playedSentences = [];
    currentSentenceIndex = Math.floor(Math.random() * sentenceStarts.length);
    playedSentences.push(currentSentenceIndex);
    idx = sentenceStarts[currentSentenceIndex];
    originalSentence = getSentenceText(tokens, currentSentenceIndex);
    
    // Appliquer le fond choisi Ã  l'overlay
    const bgColor = (bgColorPicker?.getColor()?.toHEXA().toString()) || '#ffffff';
    document.body.style.backgroundColor = bgColor;
    
    openGamePlayOverlayDirect();
    return;
  }
  
  // Mode normal avec page de lecture
  document.getElementById('homePage').style.display = 'none';
  const dp = document.getElementById('displayPage');
  dp.style.display = 'block';
  dp.style.visibility = 'visible';
  
  if (gameMode) {
    highlightWords = [];
  } else {
    highlightWords = [...readModeHighlightWords];
  }

  const initialBg = (bgColorPicker?.getColor()?.toHEXA().toString()) || '#ffffff';
  const contrast0 = getContrastingColor(initialBg);
  applyControlsTheme(contrast0);

  wireInfoOverlayControls();

  if (gameMode) {
    sentenceStarts = computeSentenceStarts(tokens);
    playedSentences = [];
    currentSentenceIndex = 0;
    toggleGameBars(true);
    updateGameBarNavigation();
  } else {
    toggleGameBars(false);
    toggleGameBarsNoRead(false);
  }

  clearInterval(timer);
  playing = false;
  showToken(tokens[idx]);
  if (typeof fitCharLine === 'function') fitCharLine();
}

// ========= Navigation par phrase =========
const SENT_END_RE = /[ãï¼ï¼.!?]$/;

function computeSentenceStarts(tokArr){
  const starts = [0];
  for (let i=0;i<tokArr.length;i++){
    if (SENT_END_RE.test(tokArr[i].text)) starts.push(i+1);
  }
  if (starts[starts.length-1] === tokArr.length) starts.pop();
  return starts;
}

function findCurrentSentenceIndex(tokArr, currentIdx) {
  const starts = computeSentenceStarts(tokArr);
  for (let i = 0; i < starts.length; i++) {
    if (i === starts.length - 1) return i;
    if (currentIdx >= starts[i] && currentIdx < starts[i + 1]) return i;
  }
  return 0;
}

function getSentenceText(tokArr, sentenceIdx) {
  const starts = computeSentenceStarts(tokArr);
  if (sentenceIdx >= starts.length) return '';
  
  const startIdx = starts[sentenceIdx];
  let endIdx = tokArr.length;
  
  if (sentenceIdx < starts.length - 1) {
    endIdx = starts[sentenceIdx + 1];
  }
  
  return tokArr.slice(startIdx, endIdx).map(t => t.text).join('');
}

// ========= Couleurs =========
function getContrastingColor(hex){
  hex = hex.replace('#','');
  if(hex.length === 3) hex = hex.split('').map(c=>c+c).join('');
  const r = parseInt(hex.substr(0,2),16);
  const g = parseInt(hex.substr(2,2),16);
  const b = parseInt(hex.substr(4,2),16);
  const luminance = (0.299*r + 0.587*g + 0.114*b) / 255;
  return luminance > 0.6 ? "#000000" : "#ffffff";
}

// ========= Repositionnement =========
function restartFrom(index){
  const text = normalizeChineseText(document.getElementById('inputText').value);
  tokens = attachDictInfo(segmentText(text, dict.wordSet, dict.maxLen), dict.entries);
  
  if (gameMode) {
    sentenceStarts = computeSentenceStarts(tokens);
  }
  
  if (!tokens.length) return;

  idx = Math.max(0, Math.min(index, tokens.length-1));
  clearInterval(timer);
  showToken(tokens[idx]);
  fitCharLine && fitCharLine();
}

// ========= Boucle =========
function updatePlayGameBtnIcon() {
  const btn = document.getElementById('playGameBtn');
  if (!btn) return;

  if (playing) {
    // IcÃ´ne Pause II
    btn.innerHTML = `
      <svg class="icon" viewBox="0 0 24 24" fill="currentColor">
        <rect x="7" y="6" width="3" height="12"></rect>
        <rect x="14" y="6" width="3" height="12"></rect>
      </svg>`;
  } else {
    // IcÃ´ne Lecture â¶
    btn.innerHTML = `
      <svg class="icon" viewBox="0 0 24 24" fill="currentColor">
        <polygon points="8,6 18,12 8,18"></polygon>
      </svg>`;
  }
}
function forcePause(){
  playing = false;
  clearInterval(timer);
  const pb = document.getElementById('pauseIcon');
  if (pb) pb.innerHTML = '<polygon points="8,6 18,12 8,18"></polygon>';
  updatePlayGameBtnIcon(); // â ajoute Ã§a
}

function forcePlay(skipFirst = false){
  if (!tokens || !tokens.length) return;
  if (gameMode && gameType === 'reorderNoRead') return;

  playing = true;
  const pb = document.getElementById('pauseIcon');
  if (pb) pb.innerHTML = '<rect x="7" y="6" width="3" height="12" fill="currentColor"></rect>'
                       + '<rect x="14" y="6" width="3" height="12" fill="currentColor"></rect>';
  
  if (!skipFirst) showToken(tokens[idx]);
  startLoop(skipFirst);
  updatePlayGameBtnIcon(); // â ajoute Ã§a
}

function startLoop(skipFirst = false){
  const speedEl = document.getElementById('speed');
  const speed = +(speedEl?.value || 120);
  const ms = Math.max(50, Math.round(60000 / Math.max(1, speed)));
  clearInterval(timer);

  let first = skipFirst;
  timer = setInterval(() => {
    if (!playing) return;

    if (first) {         // on saute la 1re itÃ©ration si demandÃ©
      first = false;
      return;
    }

    idx++;
    if (idx < tokens.length) {
      showToken(tokens[idx]);

      // Si on est en mode jeu (sauf reorderNoRead) et quâon finit une phrase â ouvrir lâoverlay
      if (gameMode && gameType !== 'reorderNoRead' && SENT_END_RE.test(tokens[idx].text)) {
        forcePause();
        setTimeout(() => { openGameModeOverlay(); }, 500);
        return;
      }

      // Pause sur mot surlignÃ©
      const clean = tokens[idx].text.replace(/[ãï¼ï¼,.ï¼!?]$/,'');
      if (highlightWords.includes(clean)) {
        forcePause();
      }
    } else {
      // fin du texte
      forcePause();
      // (option) on se remet au dÃ©but pour que â¶ relance depuis le dÃ©but
      idx = 0;
      updatePlayGameBtnIcon();
    }
  }, ms);
}

// ========= UI Management =========
function updateUI() {
  const readMode = document.getElementById('readMode').checked;
  const gameMode = document.getElementById('gameMode').checked;
  
  const toggleEdit = document.getElementById('toggleEdit');
  const pinyinOption = document.getElementById('pinyinOption');
  const translationOption = document.getElementById('translationOption');
  const selectionOption = document.getElementById('selectionOption');
  const highlightBgSwatch = document.getElementById('highlightBgSwatch');
  const highlightColorSwatch = document.getElementById('highlightColorSwatch');
  const gameModeOptions = document.getElementById('gameModeOptions');
  
  if (readMode) {
    toggleEdit.style.display = 'flex';
    pinyinOption.style.display = 'flex';
    translationOption.style.display = 'flex';
    selectionOption.style.display = 'flex';
    highlightBgSwatch.style.display = 'block';
    highlightColorSwatch.style.display = 'block';
    gameModeOptions.style.display = 'none';
  } else if (gameMode) {
    toggleEdit.style.display = 'none';
    pinyinOption.style.display = 'flex';
    translationOption.style.display = 'flex';
    selectionOption.style.display = 'none';
    highlightBgSwatch.style.display = 'none';
    highlightColorSwatch.style.display = 'none';
    gameModeOptions.style.display = 'block';
  }
}

// ========= Taille =========
function fitCharLine() {
  const container = document.getElementById('charContainer');
  const display   = document.getElementById('charDisplay');
  if (!container || !display) return;

  const isMobile = window.matchMedia('(max-width: 600px)').matches;
  const symbols  = display.querySelectorAll('.han, .punc').length;

  if (isMobile) {
    if (symbols <= 3) {
      display.style.fontSize = '80px';
      return;
    }
    let size = 140, minPx = 28, guard = 30;
    display.style.fontSize = size + 'px';
    while (guard-- > 0 && (display.scrollWidth > container.clientWidth * 0.95 || display.scrollHeight > container.clientHeight * 0.95)) {
      size = Math.max(minPx, Math.floor(size * 0.92));
      display.style.fontSize = size + 'px';
    }
    return;
  }

  let maxPx = Math.min(Math.floor(container.clientWidth * 0.85), 180), minPx = 28, size=maxPx, guard=30;
  display.style.fontSize = size + 'px';
  while (guard-- > 0 && (display.scrollWidth > container.clientWidth * 0.98 || display.scrollHeight > container.clientHeight * 0.98)) {
    size = Math.max(minPx, Math.floor(size * 0.92));
    display.style.fontSize = size + 'px';
  }
}

// ========= Fonctions MODE JEU =========
function normalizeForComparison(text) {
  return text
    .toLowerCase()
    .replace(/[ãï¼ï¼,.ï¼!?:ï¼;ï¼'"\"ãããã''""ããï¼ï¼()â¦â\-\s]/g, '')
    .trim();
}

function extractWordsFromSentence(sentence) {
  const segmented = segmentText(sentence, dict.wordSet, dict.maxLen);
  const words = [];
  
  segmented.forEach(token => {
    if (token.text.trim()) {
      words.push(token.text);
    }
  });
  
  return words;
}

function shuffleArray(array) {
  const shuffled = [...array];
  for (let i = shuffled.length - 1; i > 0; i--) {
    const j = Math.floor(Math.random() * (i + 1));
    [shuffled[i], shuffled[j]] = [shuffled[j], shuffled[i]];
  }
  return shuffled;
}

function applyGameTheme() {
  const normalBg = (bgColorPicker?.getColor()?.toHEXA().toString()) || '#ffffff';
  const normalText = (textColorPicker?.getColor()?.toHEXA().toString()) || '#000000';
  const highlightBg = (highlightBgColorPicker?.getColor()?.toHEXA().toString()) || '#000000';
  const highlightText = (highlightColorPicker?.getColor()?.toHEXA().toString()) || '#ffffff';
  
  const clean = tokens[idx]?.text?.replace(/[ãï¼ï¼,.ï¼!?]$/, '') || '';
  const isHighlighted = highlightWords.includes(clean);
  
  const pageBg = isHighlighted ? highlightBg : normalBg;
  const pageText = isHighlighted ? highlightText : normalText;
  
  const overlays = ['#gameModeOverlay', '#gamePlayOverlay'];
  overlays.forEach(selector => {
    const overlay = document.querySelector(selector);
    if (overlay) {
      const content = overlay.querySelector('.game-overlay-content');
      if (content) {
        content.style.background = pageBg;
        content.style.color = pageText;
      }
    }
  });
}

function toggleGameBars(showGameBars) {
  const normalBar = document.getElementById('barDefault');
  const ghostBar = document.getElementById('ghostBar');
  const gameBars = document.getElementById('gameBars');
  const gameBarsNoRead = document.getElementById('gameBarsNoRead');
  const hamburger = document.getElementById('hamburger');
  const displayPage = document.getElementById('displayPage');
  
  if (showGameBars) {
    normalBar.style.display = 'none';
    ghostBar.style.display = 'none';
    gameBars.style.display = 'block';
    gameBarsNoRead.style.display = 'none';
    displayPage.classList.add('game-mode-active');
    
    if (hamburger) {
      hamburger.style.display = 'flex';
    }
  } else {
    normalBar.style.display = 'grid';
    ghostBar.style.display = 'none';
    gameBars.style.display = 'none';
    gameBarsNoRead.style.display = 'none';
    displayPage.classList.remove('game-mode-active');
  }
}

function toggleGameBarsNoRead(show) {
  const normalBar = document.getElementById('barDefault');
  const ghostBar = document.getElementById('ghostBar');
  const gameBars = document.getElementById('gameBars');
  const gameBarsNoRead = document.getElementById('gameBarsNoRead');
  const displayPage = document.getElementById('displayPage');
  
  if (show) {
    normalBar.style.display = 'none';
    ghostBar.style.display = 'none';
    gameBars.style.display = 'none';
    gameBarsNoRead.style.display = 'block';
    displayPage.classList.add('game-mode-active');
  } else {
    normalBar.style.display = 'grid';
    ghostBar.style.display = 'none';
    gameBars.style.display = 'none';
    gameBarsNoRead.style.display = 'none';
    displayPage.classList.remove('game-mode-active');
  }
}

function goToPreviousSentence() {
  if (currentSentenceIndex > 0) {
    currentSentenceIndex--;
    const startIdx = sentenceStarts[currentSentenceIndex];
    restartFrom(startIdx);
    originalSentence = getSentenceText(tokens, currentSentenceIndex);
    updateGameNavigation();
    updateGameBarNavigation();

    setTimeout(() => { forcePlay(); }, 300);
  } else {
    // dÃ©jÃ  Ã  la premiÃ¨re phrase â revenir au dÃ©but de celle-ci
    const startIdx = sentenceStarts[0];
    restartFrom(startIdx);
    forcePause(); // en pause au dÃ©but
  }
}

function goToNextSentence() {
  if (currentSentenceIndex < sentenceStarts.length - 1) {
    currentSentenceIndex++;
    const startIdx = sentenceStarts[currentSentenceIndex];
    restartFrom(startIdx);
    originalSentence = getSentenceText(tokens, currentSentenceIndex);
    updateGameNavigation();
    updateGameBarNavigation();
    
    if (gameType === 'reorderNoRead') {
      openGamePlayOverlayDirect();
    } else {
      // Relancer la lecture automatiquement pour les autres modes
      setTimeout(() => {
        forcePlay();
      }, 300);
    }
  }
}

function goToRandomSentence() {
  if (sentenceStarts.length <= 1) return;
  
  // Si toutes les phrases ont Ã©tÃ© jouÃ©es, rÃ©initialiser
  if (playedSentences.length >= sentenceStarts.length) {
    playedSentences = [];
  }
  
  // Trouver les phrases non encore jouÃ©es
  const availableSentences = [];
  for (let i = 0; i < sentenceStarts.length; i++) {
    if (!playedSentences.includes(i)) {
      availableSentences.push(i);
    }
  }
  
  // S'il ne reste qu'une phrase non jouÃ©e, la prendre
  if (availableSentences.length === 1) {
    currentSentenceIndex = availableSentences[0];
  } else {
    // Sinon, choisir alÃ©atoirement parmi les phrases non jouÃ©es
    const randomIdx = Math.floor(Math.random() * availableSentences.length);
    currentSentenceIndex = availableSentences[randomIdx];
  }
  
  // Marquer cette phrase comme jouÃ©e
  if (!playedSentences.includes(currentSentenceIndex)) {
    playedSentences.push(currentSentenceIndex);
  }
  
  const startIdx = sentenceStarts[currentSentenceIndex];
  idx = startIdx;
  originalSentence = getSentenceText(tokens, currentSentenceIndex);
  updateGameNavigation();
  
  // En mode reorderNoRead, juste recharger le contenu de l'overlay
  if (gameType === 'reorderNoRead') {
    // S'assurer que l'overlay est visible
    const overlay = document.getElementById('gamePlayOverlay');
    if (overlay.style.display !== 'flex') {
      overlay.style.display = 'flex';
    }
    // Recharger le jeu
    initReorderGame();
  } else {
    initReorderGame();
  }
}

function replaySentence() {
  const startIdx = sentenceStarts[currentSentenceIndex];
  restartFrom(startIdx);
  forcePause();
  closeGameModeOverlay();
  closeGamePlayOverlay();
  setTimeout(() => {
    forcePlay();
  }, 300);
}

function updateGameBarNavigation() {
  const prevBtn = document.getElementById('prevSentenceBtn');
  const nextBtn = document.getElementById('nextSentenceBtn');
  const playBtn = document.getElementById('playGameBtn');
  const prevBtnNoRead = document.getElementById('prevSentenceNoReadBtn');
  const nextBtnNoRead = document.getElementById('nextSentenceNoReadBtn');
  
  if (prevBtn) prevBtn.disabled = currentSentenceIndex === 0;
  if (nextBtn) nextBtn.disabled = currentSentenceIndex >= sentenceStarts.length - 1;
  if (prevBtnNoRead) prevBtnNoRead.disabled = currentSentenceIndex === 0;
  if (nextBtnNoRead) nextBtnNoRead.disabled = currentSentenceIndex >= sentenceStarts.length - 1;
  
  if (playBtn) playBtn.disabled = false;
}

function openGameManually() {
  currentSentenceIndex = findCurrentSentenceIndex(tokens, idx);
  originalSentence = getSentenceText(tokens, currentSentenceIndex);
  
  if (gameType === 'both') {
    openGameModeOverlay();
  } else if (gameType === 'reorder' || gameType === 'reorderNoRead') {
    openGamePlayOverlay('reorder');
  } else if (gameType === 'free') {
    openGamePlayOverlay('free');
  }
}

function openGameModeOverlay() {
  currentSentenceIndex = findCurrentSentenceIndex(tokens, idx);
  originalSentence = getSentenceText(tokens, currentSentenceIndex);
  
  const overlay = document.getElementById('gameModeOverlay');
  overlay.style.display = 'flex';
  applyGameTheme();
  
  const prevBtn = document.getElementById('prevSentenceGame');
  const nextBtn = document.getElementById('nextSentenceGame');
  
  prevBtn.disabled = currentSentenceIndex === 0;
  nextBtn.disabled = currentSentenceIndex >= sentenceStarts.length - 1;
}

function closeGameModeOverlay() {
  document.getElementById('gameModeOverlay').style.display = 'none';
}

function openGamePlayOverlay(mode) {
  currentGameMode = mode;
  closeGameModeOverlay();
  
  const overlay = document.getElementById('gamePlayOverlay');
  overlay.style.display = 'flex';
  applyGameTheme();
  
  const reorderBtn = document.getElementById('switchReorder');
  const freeBtn = document.getElementById('switchFree');
  const switcher = document.querySelector('.mode-switcher');
  
  // GÃ©rer la visibilitÃ© de la croix de fermeture
const closeBtn = document.getElementById('closeGamePlay');
if (closeBtn) {
  if (gameType === 'reorderNoRead') {
    closeBtn.style.display = 'none';
  } else {
    closeBtn.style.display = 'block';
  }
}
  
  // Hide switcher based on game type
  if (gameType === 'reorder' || gameType === 'reorderNoRead') {
    switcher.style.display = 'none';
    mode = 'reorder';
  } else if (gameType === 'free') {
    switcher.style.display = 'none';
    mode = 'free';
  } else {
    switcher.style.display = 'flex';
  }
  
  if (mode === 'reorder') {
    reorderBtn.classList.add('active');
    freeBtn.classList.remove('active');
    document.getElementById('reorderGame').style.display = 'block';
    document.getElementById('freeGame').style.display = 'none';
    initReorderGame();
  } else {
    freeBtn.classList.add('active');
    reorderBtn.classList.remove('active');
    document.getElementById('freeGame').style.display = 'block';
    document.getElementById('reorderGame').style.display = 'none';
    initFreeGame();
  }
  
  // GÃ©rer les boutons selon le mode
const replayBtn = document.getElementById('replayInGame');
const prevBtn = document.getElementById('prevSentenceInGame');
const nextBtn = document.getElementById('nextSentenceInGame');

if (gameType === 'reorderNoRead') {
  // MODE RÃORGANISER SANS LECTURE - Comportement spÃ©cial
  if (replayBtn) replayBtn.style.display = 'none';
  
  if (prevBtn) {
    prevBtn.textContent = 'â Quitter';
    prevBtn.disabled = false;
    prevBtn.onclick = () => {
      closeGamePlayOverlay();
      document.body.style.backgroundColor = '';
      idx = 0;
      document.getElementById('homePage').style.display = 'block';
    };
  }
  
  if (nextBtn) {
    nextBtn.textContent = 'Suivante â';
    nextBtn.disabled = false;
    nextBtn.onclick = () => {
      // Action alÃ©atoire derriÃ¨re le bouton "Suivante"
      goToRandomSentence();
    };
  }
} else {
  // AUTRES MODES - Comportement normal
  if (replayBtn) replayBtn.style.display = 'block';
  
  if (prevBtn) {
    prevBtn.textContent = 'â PrÃ©cÃ©dente';
    prevBtn.onclick = () => {
      goToPreviousSentence();
      closeGamePlayOverlay();
    };
  }
  
  if (nextBtn) {
    nextBtn.textContent = 'Suivante â';
    nextBtn.onclick = () => {
      goToNextSentence();
      closeGamePlayOverlay();
    };
  }
}

updateGameNavigation();
}

function openGamePlayOverlayDirect() {
  currentSentenceIndex = findCurrentSentenceIndex(tokens, idx);
  originalSentence = getSentenceText(tokens, currentSentenceIndex);
  openGamePlayOverlay('reorder');
}

function closeGamePlayOverlay() {
  document.getElementById('gamePlayOverlay').style.display = 'none';
}

function updateGameNavigation() {
  const prevBtn = document.getElementById('prevSentenceInGame');
  const nextBtn = document.getElementById('nextSentenceInGame');
  
  // En mode reorderNoRead, les boutons ont un comportement spÃ©cial et ne doivent jamais Ãªtre dÃ©sactivÃ©s
  if (gameType === 'reorderNoRead') {
    if (prevBtn) {
      prevBtn.disabled = false;
      prevBtn.style.opacity = '1';
      prevBtn.style.cursor = 'pointer';
    }
    if (nextBtn) {
      nextBtn.disabled = false;
      nextBtn.style.opacity = '1';
      nextBtn.style.cursor = 'pointer';
    }
  } else {
    // Mode normal
    if (prevBtn) prevBtn.disabled = currentSentenceIndex === 0;
    if (nextBtn) nextBtn.disabled = currentSentenceIndex >= sentenceStarts.length - 1;
  }
}

function initReorderGame() {
  const words = extractWordsFromSentence(originalSentence);
  const shuffledWords = shuffleArray(words);
  
  const availableWordsContainer = document.getElementById('availableWords');
  const userSentenceContainer = document.getElementById('userSentence');
  
  availableWordsContainer.innerHTML = '';
  userSentenceContainer.innerHTML = '';
  
  shuffledWords.forEach(word => {
    const token = createWordToken(word);
    availableWordsContainer.appendChild(token);
  });
  
  document.getElementById('reorderResult').style.display = 'none';
  document.getElementById('retryReorder').style.display = 'none';
  document.getElementById('validateReorder').style.display = 'block';
  
  setupDragAndDrop();
}

function createWordToken(text) {
  const token = document.createElement('div');
  token.className = 'word-token';
  token.textContent = text;
  token.draggable = true;
  
  token.addEventListener('click', (e) => {
    e.preventDefault();
    const availableContainer = document.getElementById('availableWords');
    const userContainer = document.getElementById('userSentence');
    
    if (token.parentNode === availableContainer) {
      userContainer.appendChild(token);
    } else {
      availableContainer.appendChild(token);
    }
  });
  
  return token;
}


function setupDragAndDrop() {
  const containers = ['availableWords', 'userSentence'];
  
  containers.forEach(containerId => {
    const container = document.getElementById(containerId);
    
    container.addEventListener('dragover', (e) => {
  e.preventDefault();
  const dragging = document.querySelector('.dragging');
  if (!dragging) return;
  
  const afterElement = getDragAfterElement(container, e.clientX, e.clientY);
  if (afterElement == null) {
    container.appendChild(dragging);
  } else {
    container.insertBefore(dragging, afterElement);
  }
});
    
    container.addEventListener('drop', (e) => {
      e.preventDefault();
    });
  });
  
  document.addEventListener('dragstart', (e) => {
    if (e.target.classList.contains('word-token')) {
      e.target.classList.add('dragging');
      e.dataTransfer.effectAllowed = 'move';
    }
  });
  
  document.addEventListener('dragend', (e) => {
    if (e.target.classList.contains('word-token')) {
      e.target.classList.remove('dragging');
    }
  });
}

function getDragAfterElement(container, x, y) {
  const els = [...container.querySelectorAll('.word-token:not(.dragging)')];
  if (!els.length) return null;

  // Construire les lignes (tolÃ©rance Y)
  const TOL = 8;
  const lines = [];
  for (const node of els) {
    const rects = Array.from(node.getClientRects());
    for (const r of rects) {
      let line = lines.find(L => Math.abs(L.top - r.top) <= TOL);
      if (!line) {
        line = { top: r.top, bottom: r.bottom, items: [] };
        lines.push(line);
      } else {
        line.top = Math.min(line.top, r.top);
        line.bottom = Math.max(line.bottom, r.bottom);
      }
      line.items.push({ node, rect: r });
    }
  }
  lines.sort((a, b) => a.top - b.top);
  lines.forEach(L => L.items.sort((a, b) => a.rect.left - b.rect.left));

  // Choisir la ligne la plus proche en Y
  let bestLine = null, bestDy = Infinity;
  for (const L of lines) {
    const cy = (L.top + L.bottom) / 2;
    const dy = Math.abs(y - cy);
    if (dy < bestDy) { bestDy = dy; bestLine = L; }
  }

  if (!bestLine || !bestLine.items.length) return null;

  // DÃ©but de ligne : renvoyer le 1er Ã©lÃ©ment (insertion avant lui)
  const first = bestLine.items[0];
  if (x < first.rect.left) return first.node;

  // Fin de ligne : renvoyer null pour indiquer "append at end of this line"
  const last = bestLine.items[bestLine.items.length - 1];
  if (x > last.rect.right) return last.node.nextSibling || null;

  // Entre deux : trouver lâÃ©lÃ©ment aprÃ¨s lequel insÃ©rer
  let chosen = null, bestDx = Infinity;
  for (const it of bestLine.items) {
    const midX = (it.rect.left + it.rect.right) / 2;
    const dx = x - midX;
    const adx = Math.abs(dx);
    if (adx < bestDx) { bestDx = adx; chosen = { it, dx }; }
  }
  // si x est Ã  gauche du centre â on insÃ¨re avant lâÃ©lÃ©ment; sinon aprÃ¨s
  if (chosen.dx < 0) return chosen.it.node;               // insertBefore(chosen.it.node)
  return chosen.it.node.nextSibling || null;              // insertAfter
}


function initFreeGame() {
  const textarea = document.getElementById('freeTextInput');
  textarea.value = '';
  textarea.focus();
  
  document.getElementById('freeResult').style.display = 'none';
  document.getElementById('retryFree').style.display = 'none';
  document.getElementById('validateFree').style.display = 'block';
}

function validateReorderGame() {
  const userSentenceContainer = document.getElementById('userSentence');
  const userWords = Array.from(userSentenceContainer.children).map(token => token.textContent);
  const userSentence = userWords.join('');
  
  const isCorrect = normalizeForComparison(userSentence) === normalizeForComparison(originalSentence);
  
  const resultDiv = document.getElementById('reorderResult');
  resultDiv.style.display = 'block';
  resultDiv.className = 'result-message ' + (isCorrect ? 'success' : 'error');
  
  if (isCorrect) {
    resultDiv.textContent = 'â Bravo ! La phrase est correcte : ' + originalSentence;
  } else {
    resultDiv.textContent = 'â Incorrect. RÃ©essayez !';
  }
  
  document.getElementById('validateReorder').style.display = 'none';
  document.getElementById('retryReorder').style.display = 'block';
}

function validateFreeGame() {
  const textarea = document.getElementById('freeTextInput');
  const userText = textarea.value.trim();
  
  const isCorrect = normalizeForComparison(userText) === normalizeForComparison(originalSentence);
  
  const resultDiv = document.getElementById('freeResult');
  resultDiv.style.display = 'block';
  resultDiv.className = 'result-message ' + (isCorrect ? 'success' : 'error');
  
  if (isCorrect) {
    resultDiv.textContent = 'â Bravo ! La phrase est correcte : ' + originalSentence;
  } else {
    resultDiv.textContent = 'â Incorrect. RÃ©essayez !';
  }
  
  document.getElementById('validateFree').style.display = 'none';
  document.getElementById('retryFree').style.display = 'block';
}

function switchGameMode(newMode) {
  currentGameMode = newMode;
  
  const reorderBtn = document.getElementById('switchReorder');
  const freeBtn = document.getElementById('switchFree');
  const reorderGame = document.getElementById('reorderGame');
  const freeGame = document.getElementById('freeGame');
  
  if (newMode === 'reorder') {
    reorderBtn.classList.add('active');
    freeBtn.classList.remove('active');
    reorderGame.style.display = 'block';
    freeGame.style.display = 'none';
    initReorderGame();
  } else {
    freeBtn.classList.add('active');
    reorderBtn.classList.remove('active');
    freeGame.style.display = 'block';
    reorderGame.style.display = 'none';
    initFreeGame();
  }
}

// ========= Overlays =========
function openSelectionOverlay() {
  const text = normalizeChineseText(document.getElementById('inputText').value);
  const segmented = attachDictInfo(segmentText(text, dict.wordSet, dict.maxLen), dict.entries);
  const container = document.getElementById('segmentedOverlayText');
  container.innerHTML = '';

  segmented.forEach((tok) => {
    const el = document.createElement('span');
    el.textContent = tok.text;
    const clean = tok.text.replace(/[ãï¼ï¼,.ï¼!?]$/, '');
if (readModeHighlightWords.includes(clean)) el.classList.add('selected');
    
el.addEventListener('click', () => {
  if (readModeHighlightWords.includes(clean)) readModeHighlightWords = readModeHighlightWords.filter(w => w !== clean);
  else readModeHighlightWords.push(clean);
  openSelectionOverlay();
});
    
    container.appendChild(el);
  });

  document.getElementById('selectionOverlay').style.display = 'flex';
}

function closeSelectionOverlay() {
  document.getElementById('selectionOverlay').style.display = 'none';
}

function openInfoOverlay() {
  const overlay = document.getElementById('infoOverlay');
  const body = document.getElementById('infoWords');
  if (!overlay || !body) return;
  
  infoWasPlaying = !!playing;
  forcePause();
  
  body.innerHTML = '';
  
  const normalBg = (bgColorPicker?.getColor()?.toHEXA().toString()) || '#ffffff';
  const normalText = (textColorPicker?.getColor()?.toHEXA().toString()) || '#000000';
  const highlightBg = (highlightBgColorPicker?.getColor()?.toHEXA().toString()) || '#ef4444';
  const highlightText = (highlightColorPicker?.getColor()?.toHEXA().toString()) || '#ffffff';
  
  const cleanCurrent = tokens[idx]?.text?.replace(/[ãï¼ï¼ãï¼ï¼ï¼,.!?\u201D]$/u,'') || '';
  const isH = highlightWords.includes(cleanCurrent);
  
  const pageBg = isH ? highlightBg : normalBg;
  const pageFg = isH ? highlightText : normalText;
  
  overlay.style.setProperty('--info-bg', pageBg);
  overlay.style.setProperty('--info-fg', pageFg);
  
  tokens.forEach((tok, i) => {
    const span = document.createElement('span');
    span.textContent = tok.text;
    span.className = 'info-word';
    
    const clean = tok.text.replace(/[ãï¼ï¼ãï¼ï¼ï¼,.!?\u201D]$/u,'');
    if (highlightWords.includes(clean)) span.classList.add('initialSelected');
    if (i === idx) span.classList.add('current');
    
    span.onclick = () => {
      infoChosenIndex = i;
      body.querySelectorAll('.info-word.chosen').forEach(el => el.classList.remove('chosen'));
      span.classList.add('chosen');
    };
    
    body.appendChild(span);
  });
  
  overlay.style.display = 'flex';
}

function closeInfoOverlay() {
  document.getElementById('infoOverlay').style.display = 'none';
}

function wireInfoOverlayControls() {
  const infoBtn = document.getElementById('infoBtn');
  const infoValidateBtn = document.getElementById('infoValidateBtn');
  const infoCancelBtn = document.getElementById('infoCancelBtn');
  const infoCloseBtn = document.getElementById('infoCloseBtn');
  
  if (!infoBtn || !infoValidateBtn || !infoCancelBtn || !infoCloseBtn) return;
  
  infoBtn.onclick = () => { openInfoOverlay(); };
  
  infoValidateBtn.onclick = () => {
    if (infoChosenIndex != null) {
      restartFrom(infoChosenIndex);
      forcePause();
    }
    closeInfoOverlay();
  };
  
  const cancel = () => {
    closeInfoOverlay();
    if (infoWasPlaying) forcePlay();
    infoWasPlaying = false;
    infoChosenIndex = null;
  };
  
  infoCancelBtn.onclick = cancel;
  infoCloseBtn.onclick = cancel;
}

function enableMobileDnD() {
  const isMobile = matchMedia('(pointer:coarse)').matches && matchMedia('(hover: none)').matches;
  if (!isMobile) return;

  const pool = document.getElementById('availableWords');
  const sentence = document.getElementById('userSentence');
  if (!pool || !sentence) return; // sÃ©curitÃ©
  
   const FINGER_OFFSET_X = 0; // dÃ©calage horizontal du fantÃ´me par rapport au doigt
  const FINGER_OFFSET_Y = -30; // dÃ©calage vertical du fantÃ´me

  let pressTimer = null, dragging = false;
  let srcEl = null, ghost = null, placeholder = null, caret = null, activeContainer = null;

  // Long press pour entrer en mode drag
  const LONG_PRESS_MS = 180;

  // Attach sur les conteneurs (dÃ©lÃ©gation)
  [pool, sentence].forEach(zone => {
    zone.addEventListener('pointerdown', onPointerDown, { passive: true });
  });

  // EmpÃªche le scroll pendant le drag
  window.addEventListener('pointermove', onPointerMove, { passive: false });
  window.addEventListener('pointerup', onPointerUp, { passive: true });
  window.addEventListener('pointercancel', onPointerUp, { passive: true });

  function onPointerDown(e) {
    const token = e.target.closest('.word-token');
    if (!token) return;
    if (pressTimer) clearTimeout(pressTimer);

    srcEl = token;
    pressTimer = setTimeout(() => {
      startDrag(e);
    }, LONG_PRESS_MS);
  }

  function startDrag(e) {
    dragging = true;
    // fantÃ´me
    ghost = srcEl.cloneNode(true);
    ghost.classList.add('drag-ghost');
    document.body.appendChild(ghost);

    // placeholder (mÃªme largeur approx. pour garder la mise en ligne)
    placeholder = document.createElement('span');
    placeholder.className = 'placeholder-token';
    placeholder.style.width = Math.ceil(srcEl.getBoundingClientRect().width) + 'px';

    // caret (barre dâinsertion)
    caret = document.createElement('div');
    caret.className = 'drop-caret';
    caret.style.display = 'none';
    document.body.appendChild(caret);

// dimensions de la source
const r = srcEl.getBoundingClientRect();

// fantÃ´me dÃ©jÃ  clonÃ© -> rien Ã  faire ici, il prend la taille du token

// placeholder : mÃªme largeur ET hauteur que le token
placeholder = document.createElement('span');
placeholder.className = 'placeholder-token';
placeholder.style.width  = Math.ceil(r.width)  + 'px';
placeholder.style.height = Math.ceil(r.height) + 'px';
placeholder.style.lineHeight = Math.ceil(r.height) + 'px'; // cohÃ©rence verticale

// caret : mÃªme hauteur que le token
caret = document.createElement('div');
caret.className = 'drop-caret';
caret.style.height = Math.ceil(r.height) + 'px';
caret.style.display = 'none';
document.body.appendChild(caret);

    // source invisible pendant le drag
    srcEl.classList.add('drag-source');

    // dÃ©finir container actif (au dÃ©part, celui dâorigine)
    activeContainer = srcEl.parentElement;

    // insÃ©rer placeholder Ã  la position dâorigine (avant la source)
    activeContainer.insertBefore(placeholder, srcEl);

    // activer style âonâ
    [pool, sentence].forEach(z => z.classList.add('drop-zone--active'));

    moveGhost(e);
    e.preventDefault();
  }

  function onPointerMove(e) {
    if (!dragging) return;
    moveGhost(e);

    // dÃ©terminer conteneur sous le doigt
    const targetContainer = getContainerUnder(e.clientX, e.clientY) || activeContainer;
    if (targetContainer !== activeContainer) {
      activeContainer = targetContainer;
    }

    // calculer index dâinsertion dans le conteneur actif
    positionPlaceholder(activeContainer, e.clientX, e.clientY);
  }

  function onPointerUp(e) {
    if (pressTimer) {
      clearTimeout(pressTimer);
      pressTimer = null;
    }
    if (!dragging) { srcEl = null; return; }

    // Drop : remplacer placeholder par la source
    try {
      activeContainer.insertBefore(srcEl, placeholder);
    } catch(_) {}

    cleanupDrag();

    // (optionnel) dÃ©clenche ton recalcul de âbonne phraseâ si tu en as un
    // ex: updateUserSentenceOrder();  // Ã  toi de brancher si nÃ©cessaire
  }

function moveGhost(e) {
  if (!ghost) return;

  // dÃ©calage pour que le mot ne soit pas sous le doigt
  const FINGER_OFFSET_X = 0;    // centrÃ© horizontalement
  const FINGER_OFFSET_Y = -30;  // remonte le mot au-dessus du doigt

  ghost.style.left = (e.clientX + FINGER_OFFSET_X) + 'px';
  ghost.style.top  = (e.clientY + FINGER_OFFSET_Y) + 'px';
}


  function getContainerUnder(x, y) {
    // neutraliser temporairement ghost pour connaÃ®tre lâÃ©lÃ©ment sous le doigt
    ghost.style.display = 'none';
    const el = document.elementFromPoint(x, y);
    ghost.style.display = '';
    const zone = el?.closest?.('.words-container');
    return (zone === pool || zone === sentence) ? zone : null;
  }

  function positionPlaceholder(container, x, y) {
  // Cas conteneur vide
  if (!container.children.length) {
    container.appendChild(placeholder);
    caret.style.left = x + 'px';
    caret.style.top  = y + 'px';
    caret.style.display = 'block';
    return;
  }

  const children = Array.from(container.children).filter(ch => ch !== placeholder);

  // ---- 1) Construire les lignes (groupement par top avec tolÃ©rance) ----
  const TOL = 8; // px de tolÃ©rance vertical pour regrouper dans une ligne
  const lines = []; // [{ top, bottom, items: [{node, rect}] }]
  for (const node of children) {
    // Un token peut avoir plusieurs rects, on les prend tous
    const rects = Array.from(node.getClientRects());
    for (const r of rects) {
      // essayer d'attacher ce rect Ã  une ligne existante (proche en Y)
      let line = lines.find(L => Math.abs(L.top - r.top) <= TOL);
      if (!line) {
        line = { top: r.top, bottom: r.bottom, items: [] };
        lines.push(line);
      } else {
        line.top = Math.min(line.top, r.top);
        line.bottom = Math.max(line.bottom, r.bottom);
      }
      line.items.push({ node, rect: r });
    }
  }
  // trier les lignes par Y
  lines.sort((a, b) => a.top - b.top);
  // dans chaque ligne, trier les items par X
  lines.forEach(L => L.items.sort((a, b) => a.rect.left - b.rect.left));

  // ---- 2) Trouver la ligne la plus proche du pointeur (en Y) ----
  let bestLine = null, bestDy = Infinity;
  for (const L of lines) {
    // distance verticale du centre de la ligne
    const cy = (L.top + L.bottom) / 2;
    const dy = Math.abs(y - cy);
    if (dy < bestDy) { bestDy = dy; bestLine = L; }
  }
  if (!bestLine || !bestLine.items.length) {
    // fallback
    container.appendChild(placeholder);
    caret.style.left = x + 'px';
    caret.style.top  = y + 'px';
    caret.style.display = 'block';
    return;
  }

  // ---- 3) DÃ©cider la position dans CETTE ligne uniquement ----
  const first = bestLine.items[0];
  const last  = bestLine.items[bestLine.items.length - 1];

  // a) avant le tout premier de la ligne
  if (y >= bestLine.top - TOL && y <= bestLine.bottom + TOL && x < first.rect.left) {
    container.insertBefore(placeholder, first.node);
    caret.style.left = first.rect.left + 'px';
    caret.style.top  = (bestLine.top + (bestLine.bottom - bestLine.top - 28)/2) + 'px';
    caret.style.display = 'block';
    return;
  }

  // b) aprÃ¨s le tout dernier de la ligne
  if (y >= bestLine.top - TOL && y <= bestLine.bottom + TOL && x > last.rect.right) {
    container.insertBefore(placeholder, last.node.nextSibling);
    caret.style.left = last.rect.right + 'px';
    caret.style.top  = (bestLine.top + (bestLine.bottom - bestLine.top - 28)/2) + 'px';
    caret.style.display = 'block';
    return;
  }

  // c) entre deux Ã©lÃ©ments de la ligne
  // trouver lâitem dont le centre X est le plus proche
  let target = null, bestDx = Infinity;
  for (const it of bestLine.items) {
    const midX = (it.rect.left + it.rect.right) / 2;
    const dx = Math.abs(x - midX);
    if (dx < bestDx) { bestDx = dx; target = it; }
  }

  if (target) {
    const midX = (target.rect.left + target.rect.right) / 2;
    const before = x < midX;
    container.insertBefore(placeholder, before ? target.node : target.node.nextSibling);

    // Caret (feedback visuel) exactement sous le pointeur
    caret.style.left = x + 'px';
    // aligner la hauteur du caret sur la ligne courante
const lineHeight = bestLine.bottom - bestLine.top;
caret.style.top = (bestLine.top + (lineHeight - parseInt(caret.style.height || '28')) / 2) + 'px';
    caret.style.display = 'block';
  }
}


  function placeCaretNearRect(rect, at='end') {
    if (!caret) return;
    const x = (at === 'start') ? rect.left : rect.right;
    const y = rect.top + (rect.height - 28) / 2;
    caret.style.left = x + 'px';
    caret.style.top  = y + 'px';
    caret.style.display = 'block';
  }

  function cleanupDrag() {
    dragging = false;
    if (ghost?.parentNode) ghost.parentNode.removeChild(ghost);
    if (caret?.parentNode) caret.parentNode.removeChild(caret);
    if (placeholder?.parentNode) placeholder.parentNode.removeChild(placeholder);
    [pool, sentence].forEach(z => z.classList.remove('drop-zone--active'));
    if (srcEl) srcEl.classList.remove('drag-source');

    ghost = caret = placeholder = srcEl = null;
    activeContainer = null;
  }

  // Annule le drag si lâutilisateur âtapoteâ (pas dâappui long)
  window.addEventListener('pointerdown', () => {}, { passive: true });
  window.addEventListener('pointerup', () => {
    if (pressTimer) { clearTimeout(pressTimer); pressTimer = null; }
  }, { passive: true });

  // HACK : sur mobile, on masque tes flÃ¨ches de dÃ©placement si elles existent
  try {
    document.querySelectorAll('.word-controls').forEach(el => el.style.display = 'none');
  } catch(_) {}
}

// Active Ã  la fin du chargement
document.addEventListener('DOMContentLoaded', () => {
  enableMobileDnD();
});


// ========= Menu =========
function showMenu() {
  __menuHiddenByUser = false;
  
  if (gameMode) {
    if (gameType === 'reorderNoRead') {
      document.getElementById('gameBarsNoRead').style.display = 'block';
    } else {
      document.getElementById('gameBars').style.display = 'block';
    }
  } else {
    document.querySelectorAll('#barDefault .slot:not(#hamburger)').forEach(s => {
      s.style.display = 'flex';
    });
    const ghost = document.getElementById('ghostBar');
    if (ghost) {
      ghost.style.display = 'none';
      ghost.setAttribute('aria-hidden', 'true');
      ghost.setAttribute('inert', '');
    }
  }
}

function hideMenu() {
  __menuHiddenByUser = true;
  
  if (gameMode) {
    document.getElementById('gameBars').style.display = 'none';
    document.getElementById('gameBarsNoRead').style.display = 'none';
  } else {
    document.querySelectorAll('#barDefault .slot:not(#hamburger)').forEach(s => {
      s.style.display = 'none';
    });
    const ghost = document.getElementById('ghostBar');
    if (ghost) {
      ghost.style.display = 'grid';
      ghost.removeAttribute('inert');
      ghost.setAttribute('aria-hidden', 'false');
    }
  }
}

function enforceMenuState() {
  if (__menuHiddenByUser) hideMenu();
  else showMenu();
}

// ========= Events =========
window.addEventListener('resize', fitCharLine);
window.addEventListener('orientationchange', () => setTimeout(fitCharLine, 50));

function wireGhostBar() {
  const map = {
    ghostPrev: 'prevWordBtn',
    ghostPause: 'pauseBtn',
    ghostNext: 'nextWordBtn'
  };
  for (const [ghostId, realId] of Object.entries(map)) {
    const g = document.getElementById(ghostId);
    const r = document.getElementById(realId);
    if (g && r) g.onclick = (e) => { e.preventDefault(); r.click(); };
  }
}

document.addEventListener('DOMContentLoaded', () => {
highlightWords = [...readModeHighlightWords]; 
  const $ = s => document.querySelector(s);

  // Initialize UI
  updateUI();

  // Mode selection
  $('#readMode')?.addEventListener('change', () => {
    appMode = 'read';
    gameMode = false;
    updateUI();
  });
  
  $('#gameMode')?.addEventListener('change', () => {
    appMode = 'game';
    gameMode = true;
    updateUI();
  });
  
  // Game type selection
  document.querySelectorAll('input[name="gameType"]').forEach(radio => {
    radio.addEventListener('change', (e) => {
      gameType = e.target.value;
    });
  });

  // Vitesse
  $('#speed')?.addEventListener('input', e => {
    $('#speedLabel').textContent = e.target.value;
    if (playing) startLoop();
  });

  // DÃ©marrer
  $('#startBtn')?.addEventListener('click', () => {
    startDisplay();
    if (!gameMode || gameType !== 'reorderNoRead') {
      forcePlay(true);
    }
  });

  // Play / Pause
  $('#pauseBtn')?.addEventListener('click', () => {
    if (!tokens || !tokens.length) return;
    if (idx >= tokens.length - 1) { restartFrom(0); forcePlay(); return; }
    if (playing) forcePause(); else forcePlay();
  });

  // Navigation mots
  $('#prevWordBtn')?.addEventListener('click', () => { if (!tokens.length) return; restartFrom(Math.max(0, idx - 1)); forcePause(); });
  $('#nextWordBtn')?.addEventListener('click', () => { if (!tokens.length) return; restartFrom(Math.min(tokens.length - 1, idx + 1)); forcePause(); });

  // Quitter
  $('#quitBtn')?.addEventListener('click', () => {
    forcePause();
    document.getElementById('charDisplay').innerHTML = '';
    document.getElementById('pinyin').textContent = '';
    document.getElementById('defs').textContent = '';
    idx = 0;
    document.getElementById('displayPage').style.display = 'none';
    document.getElementById('homePage').style.display = 'block';
  });

  // Quitter le mode jeu
	  $('#quitGameBtn')?.addEventListener('click', () => {
  forcePause();
  
  document.getElementById('charDisplay').innerHTML = '';
  document.getElementById('pinyin').textContent = '';
  document.getElementById('defs').textContent = '';
  idx = 0;
  
  closeGameModeOverlay();
  closeGamePlayOverlay();
  
  document.getElementById('displayPage').style.display = 'none';
  toggleGameBars(false);
  toggleGameBarsNoRead(false);
  
  document.getElementById('homePage').style.display = 'block';
  // gameMode reste Ã  true, le mode sÃ©lectionnÃ© reste inchangÃ©
});
  
$('#quitGameNoReadBtn')?.addEventListener('click', () => {
  forcePause();
  closeGamePlayOverlay();
  
  document.body.style.backgroundColor = '';
  idx = 0;
  
  document.getElementById('homePage').style.display = 'block';
});

  // MODE JEU : Barres de jeu
  $('#prevSentenceBtn')?.addEventListener('click', () => {
    goToPreviousSentence();
    forcePause();
  });
  
  $('#prevSentenceNoReadBtn')?.addEventListener('click', () => {
    goToPreviousSentence();
  });

  $('#showGameBtn')?.addEventListener('click', () => {
    openGameManually();
  });
  
  $('#showGameNoReadBtn')?.addEventListener('click', () => {
    openGameManually();
  });

  $('#nextSentenceBtn')?.addEventListener('click', () => {
    goToNextSentence();
    forcePause();
  });
  
  $('#nextSentenceNoReadBtn')?.addEventListener('click', () => {
    goToNextSentence();
  });
  
  $('#randomSentenceBtn')?.addEventListener('click', () => {
    goToRandomSentence();
  });

$('#playGameBtn')?.addEventListener('click', () => {
  if (playing) {
    forcePause(); // mettre en pause
  } else {
    if (idx >= tokens.length - 1) {
      // si on Ã©tait Ã  la fin â revenir au dÃ©but
      restartFrom(0);
    }
    forcePlay(); // reprendre ou relancer
  }
  updatePlayGameBtnIcon();
});


  // OVERLAY DE SÃLECTION DE MODE
  $('#reorderModeBtn')?.addEventListener('click', () => {
    openGamePlayOverlay('reorder');
  });

  $('#freeModeBtn')?.addEventListener('click', () => {
    openGamePlayOverlay('free');
  });

  $('#closeGameMode')?.addEventListener('click', () => {
    closeGameModeOverlay();
  });

  $('#prevSentenceGame')?.addEventListener('click', () => {
  goToPreviousSentence();
  closeGameModeOverlay();
  // La lecture se relancera automatiquement via goToPreviousSentence()
});

  $('#nextSentenceGame')?.addEventListener('click', () => {
  goToNextSentence();
  closeGameModeOverlay();
  // La lecture se relancera automatiquement via goToNextSentence()
});

  $('#replayGame')?.addEventListener('click', () => {
    replaySentence();
  });

  // OVERLAY DE JEU PRINCIPAL
$('#closeGamePlay')?.addEventListener('click', () => {
  closeGamePlayOverlay();
  
  if (gameType === 'reorderNoRead') {
    // En mode rÃ©organiser sans lecture, retour direct Ã  l'accueil
    document.body.style.backgroundColor = '';
    document.getElementById('homePage').style.display = 'block';
  } else {
    // Autres modes : juste fermer l'overlay, garder la page de jeu visible
    // Ne rien faire de plus, l'overlay est dÃ©jÃ  fermÃ©
  }
});

  $('#switchReorder')?.addEventListener('click', () => {
    switchGameMode('reorder');
  });

  $('#switchFree')?.addEventListener('click', () => {
    switchGameMode('free');
  });

  $('#validateReorder')?.addEventListener('click', () => {
    validateReorderGame();
  });

  $('#retryReorder')?.addEventListener('click', () => {
    initReorderGame();
  });

  $('#validateFree')?.addEventListener('click', () => {
    validateFreeGame();
  });

  $('#retryFree')?.addEventListener('click', () => {
    initFreeGame();
  });

  $('#prevSentenceInGame')?.addEventListener('click', () => {
  goToPreviousSentence();
  closeGamePlayOverlay();
  // La lecture se relancera automatiquement via goToPreviousSentence()
});

  $('#nextSentenceInGame')?.addEventListener('click', () => {
  goToNextSentence();
  closeGamePlayOverlay();
  // La lecture se relancera automatiquement via goToNextSentence()
});

  $('#replayInGame')?.addEventListener('click', () => {
    replaySentence();
  });

  $('#freeTextInput')?.addEventListener('keydown', (e) => {
    if (e.key === 'Enter' && e.ctrlKey) {
      e.preventDefault();
      validateFreeGame();
    }
  });

  // Overlay sÃ©lection
  $('#toggleEdit')?.addEventListener('click', openSelectionOverlay);
  $('#closeOverlay')?.addEventListener('click', closeSelectionOverlay);
  $('#overlayCancelBtn')?.addEventListener('click', closeSelectionOverlay);
$('#overlayValidateBtn')?.addEventListener('click', () => {
  highlightWords = [...readModeHighlightWords];  // â AJOUTER CETTE LIGNE
  renderSegmented();
  closeSelectionOverlay();
});

  // Effacer
  $('#clearText')?.addEventListener('click', () => {
    const input = document.getElementById('inputText');
    if (!input) return;
    input.value = '';
    renderSegmented();
  });

  // Hamburger
  let hamburgerTimeout = null;
  const hamburger = document.getElementById('hamburger');
  if (hamburger) {
    hamburger.addEventListener('click', (e) => {
      e.preventDefault();
      e.stopPropagation();
      if (hamburgerTimeout) return;
      hamburgerTimeout = setTimeout(() => hamburgerTimeout = null, 200);
      if (__menuHiddenByUser) {
        showMenu();
        __menuHiddenByUser = false;
      } else {
        hideMenu();
        __menuHiddenByUser = true;
      }
    });
  }

  // Saisie / collage
  $('#inputText')?.addEventListener('paste', () => {
    setTimeout(() => {
      const input = document.getElementById('inputText');
      input.value = normalizeChineseText(input.value);
      renderSegmented();
    }, 50);
  });
  
  $('#inputText')?.addEventListener('input', e => {
    const caret = e.target.selectionStart;
    const before = e.target.value;
    const after = normalizeChineseText(before);
    if (after !== before) {
      e.target.value = after;
      e.target.setSelectionRange(caret, caret);
    }
    renderSegmented();
  });

  // Dictionnaire
  $('#loadDict')?.addEventListener('click', () => $('#dictFile').click());
  $('#dictFile')?.addEventListener('change', e => {
    const file = e.target.files[0];
    if (!file) return;
    const reader = new FileReader();
    reader.onload = () => {
      dict = parseCedict(reader.result);
      document.getElementById('dictStatus').textContent = 'Dictionnaire chargÃ© (' + dict.wordSet.size + ' mots)';
      renderSegmented();
    };
    reader.readAsText(file, 'utf-8');
  });

  // Premier rendu
  renderSegmented();
  wireGhostBar();
  showMenu();
});

// ========= Pickr =========
const bgColorPicker = Pickr.create({
  el: '#bgColorPicker',
  theme: 'classic',
  default: '#FFE103',
  components: { preview: true, opacity: true, hue: true, interaction: { hex: true, rgba: true, input: true, save: true } }
});

const textColorPicker = Pickr.create({
  el: '#textColorPicker',
  theme: 'classic',
  default: '#000000',
  components: { preview: true, opacity: true, hue: true, interaction: { hex: true, rgba: true, input: true, save: true } }
});

const highlightBgColorPicker = Pickr.create({
  el: '#highlightBgColorPicker',
  theme: 'classic',
  default: '#000000',
  components: { preview: true, opacity: true, hue: true, interaction: { hex: true, rgba: true, input: true, save: true } }
});

const highlightColorPicker = Pickr.create({
  el: '#highlightColorPicker',
  theme: 'classic',
  default: '#FFE103',
  components: { preview: true, opacity: true, hue: true, interaction: { hex: true, rgba: true, input: true, save: true } }
});


</script>

</body>
</html>
