<!DOCTYPE html>
<html lang="fr">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover">
<title>Lecteur chinois mot-à-mot</title>

<!-- Pickr (color pickers) -->
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@simonwep/pickr/dist/themes/classic.min.css"/>
<script src="https://cdn.jsdelivr.net/npm/@simonwep/pickr"></script>

<!-- Fonts -->
<link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600;700;800&family=Noto+Sans+SC:wght@500;600;700;800&display=swap" rel="stylesheet">

<style>
/* =====================================================
   Variables & Reset
   ===================================================== */
:root{
  --bg:#f6f8fb;
  --card:#ffffff;
  --brand:#0a84ff;
  --muted:#667085;
  --ring:rgba(10,132,255,.25);
  --radius:14px;
  --shadow:0 10px 28px rgba(20,20,20,.08);
  --space:clamp(14px,2.8vw,22px);
  --base:clamp(16px,3.8vw,18px);
  --h1:clamp(22px,7.2vw,34px);
  --chip:clamp(20px,5.6vw,24px);
  --textEdit:clamp(18px,4.8vw,20px);
}

*{ box-sizing:border-box }
html,body{ height:100% }
body{
  margin:0;
  font-family:"Inter",system-ui,Arial,sans-serif;
  background:transparent;
  color:#1f2937;
  font-size:var(--base);
  -webkit-text-size-adjust:100%;
}

/* =====================================================
   Home page layout
   ===================================================== */
.container{
  max-width:840px;
  margin:0 auto;
  padding:calc(var(--space) * 0.75);
}
.card{
  background:var(--card);
  border-radius:var(--radius);
  box-shadow:var(--shadow);
  padding:var(--space);
}
h1{
  font-size:var(--h1);
  text-align:center;
  margin:0 0 10px;
  color:#1976d2;
  font-weight:800;
  letter-spacing:.2px;
}

/* Mode Selector */
.mode-selector {
  display: flex;
  justify-content: center;
  gap: 20px;
  margin: 20px 0 30px;
  padding: 20px;
  background: #f0f5ff;
  border-radius: var(--radius);
}

.mode-option {
  flex: 1;
  max-width: 250px;
  text-align: center;
  cursor: pointer;
  transition: transform 0.2s ease;
}

.mode-option:hover {
  transform: translateY(-2px);
}

.mode-option input[type="radio"] {
  display: none;
}

.mode-label {
  display: block;
  padding: 20px;
  border: 3px solid #e0e7ff;
  border-radius: 12px;
  background: white;
  transition: all 0.2s ease;
}

.mode-option input[type="radio"]:checked + .mode-label {
  border-color: var(--brand);
  background: #f0f9ff;
  box-shadow: 0 4px 12px rgba(10,132,255,0.2);
}

.mode-icon {
  font-size: 32px;
  margin-bottom: 8px;
}

.mode-title {
  font-size: 18px;
  font-weight: 700;
  color: #1f2937;
  margin-bottom: 4px;
}

.mode-desc {
  font-size: 13px;
  color: var(--muted);
}

/* Game Mode Options */
.game-mode-options {
  background: #f9fafb;
  border: 1px solid #e5e7eb;
  border-radius: 12px;
  padding: 16px;
  margin-top: 16px;
  display: none;
}

.game-mode-title {
  font-weight: 700;
  color: #111827;
  margin-bottom: 12px;
  font-size: 14px;
}

.game-mode-grid {
  display: grid;
  grid-template-columns: repeat(2, 1fr);
  gap: 12px;
}

.game-mode-item {
  display: flex;
  align-items: center;
  gap: 10px;
}

.game-mode-item input[type="radio"] {
  width: 18px;
  height: 18px;
  cursor: pointer;
}

.game-mode-item label {
  cursor: pointer;
  font-size: 14px;
  font-weight: 600;
  color: #374151;
}

/* CTA bas de page (Accueil) */
.cta-bar{
  position:sticky;
  bottom:max(12px, env(safe-area-inset-bottom));
  display:flex;
  justify-content:center;
  margin-top:var(--space);
  z-index:5;
}

/* =====================================================
   Buttons (generic)
   ===================================================== */
button:not(.ctrl-btn){
  appearance:none;
  border:none;
  border-radius:12px;
  padding:14px 20px;
  font-weight:700;
  cursor:pointer;
  transition:transform .06s ease, box-shadow .2s ease, background .2s ease;
}
.btn-primary{
  background:var(--brand);
  color:#fff;
  box-shadow:0 6px 18px rgba(10,132,255,.25);
}
.btn-primary:active{ transform:scale(.98) }
.btn-ghost{ background:#eef2f7; color:#111827 }

/* =====================================================
   Editor / Segmentation
   ===================================================== */
.input-wrap{ position:relative }
textarea{
  width:100%;
  min-height:170px;
  padding:16px 18px;
  font-family:"Noto Sans SC","Inter",sans-serif;
  font-size:var(--textEdit);
  font-weight:600;
  line-height:1.65;
  background:#fff;
  color:#111827;
  border:1px solid #e5e7eb;
  border-radius:12px;
  outline:none;
  box-shadow:inset 0 1px 0 rgba(16,24,40,.02);
}
textarea:focus{ border-color:var(--brand); box-shadow:0 0 0 4px var(--ring) }

.editor-actions{
  margin-top: 6px;
  display: flex;
  justify-content: space-between;
  align-items: center;
}

.editor-btn{
  display: flex;
  align-items: center;
  justify-content: center;
  width: 32px;
  height: 32px;
  border: none;
  border-radius: 8px;
  cursor: pointer;
  background: #f3f4f6;
  box-shadow: 0 1px 3px rgba(0,0,0,.15);
  color: #111827;
  transition: background 0.2s, color 0.2s;
  transform: translateY(-3px)
}

.editor-btn:hover {
  background: #e5e7eb;
}

#clearText{
  background: none;
  box-shadow: none;
  color: #dc2626;
}

#clearText .icon {
  width: 28px;
  height: 28px;
  stroke: currentColor;
  fill: none;
}

#clearText:hover {
  background: none;
  color: #b91c1c;
}

.icon {
  width: 18px;
  height: 18px;
  flex-shrink: 0;
  display: block;
}

#toggleEdit {
  background: none;
  box-shadow: none;
  color: var(--brand);
}

#toggleEdit:hover {
  color: #0066cc;
}

#toggleEdit.icon {
  fill: currentColor;
  stroke: none;
}

.editor-btn .icon{
  width: 22px;
  height: 22px;
  display: block;
  flex-shrink: 0;
  pointer-events: none;
  fill: currentColor;
  stroke: currentColor;
}

.segmented-box{
  border:1px dashed #d8dee9;
  border-radius:12px;
  padding:10px 10px 14px;
  min-height:160px;
  background:#fafcff;
}

#segmentedText{
  overflow-x:auto; overflow-y:hidden;
  white-space:nowrap;
  -webkit-overflow-scrolling:touch;
  padding:4px 2px;
}

.token{
  display:inline-block;
  margin:6px 8px;
  padding:8px 12px;
  border-radius:999px;
  background:#f1f5f9;
  color:#0f172a;
  font-family:"Noto Sans SC","Inter",sans-serif;
  font-size:var(--chip);
  font-weight:700;
  letter-spacing:.5px;
  user-select:none;
  transition:transform .12s ease, background .2s ease, color .2s ease;
}

.token:hover{ transform:translateY(-1px) }
#segmentedText .selected{ background:#ef4444; color:#fff; transform:scale(1.04) }

/* Fieldsets */
fieldset{
  border:1px solid #e5e7eb;
  border-radius:14px;
  padding:16px;
  margin:var(--space) 0;
  background:#fff;
}
legend{ font-weight:800; color:#0f172a; padding:0 8px }

/* Slider */
.range{
  width:100%;
  margin-top:8px;
  -webkit-appearance:none; appearance:none; height:10px;
  background:linear-gradient(90deg,var(--brand),#93c5fd);
  border-radius:999px; outline:none;
}
.range::-webkit-slider-thumb{
  -webkit-appearance:none; appearance:none;
  width:28px; height:28px; border-radius:50%;
  background:#fff; border:3px solid var(--brand);
  box-shadow:0 2px 8px rgba(16,24,40,.2);
}
.range::-moz-range-thumb{
  width:28px; height:28px; border-radius:50%;
  background:#fff; border:3px solid var(--brand);
  box-shadow:0 2px 8px rgba(16,24,40,.2);
}

/* Switches */
.opt{ display:flex; align-items:center; gap:12px; margin:10px 0 }
.opt input[type="checkbox"]{
  appearance:none; width:54px; height:32px; border-radius:999px;
  background:#e5e7eb; position:relative; outline:none; cursor:pointer;
  transition:background .2s ease;
}
.opt input[type="checkbox"]::after{
  content:""; position:absolute; top:3px; left:3px;
  width:26px; height:26px; border-radius:50%;
  background:#fff; box-shadow:0 1px 4px rgba(0,0,0,.2);
  transition:left .2s ease;
}
.opt input[type="checkbox"]:checked{ background:var(--brand) }
.opt input[type="checkbox"]:checked::after{ left:25px }
.opt span{ font-weight:600; color:#111827 }

/* Pickr rows */
.color-row{
  display:flex; justify-content:space-between; gap:18px; flex-wrap:wrap; padding:8px 0;
}
.swatch{ flex:1; min-width:130px; text-align:center }
.swatch > div .pcr-button{
  width:60px; height:60px; border-radius:50%;
  box-shadow:0 3px 10px rgba(0,0,0,.12); border:none;
}
.swatch label{ margin-top:6px; font-weight:600; font-size:14px; display:block }

/* =====================================================
   Selection overlay
   ===================================================== */
#selectionOverlay .overlay-content {
  background: #ffffff;
  border-radius: 12px;
  box-shadow: 0 6px 20px rgba(0,0,0,.2);
  width: 100%;
  max-width: 760px;
  padding: 0;
  display: flex;
  flex-direction: column;
  max-height: 90vh;
}

#overlayHeader{
  flex-shrink: 0;
  padding: 12px;
  background:#f5f5f5;
  border-bottom:1px solid #ddd;
}

#closeOverlay{ background:transparent; border:none; font-size:28px; cursor:pointer; color:#444 }

#segmentedOverlayText {
  flex: 1;
  overflow-y: auto;
  padding: 16px;
  white-space: normal;
  line-height: 1.8;
}

#segmentedOverlayText span{
  display:inline-block; margin:6px 8px; padding:8px 12px;
  border-radius:6px; background:#f1f5f9; font-size:22px; font-weight:600; cursor:pointer;
}

#segmentedOverlayText span.selected{ background:#ef4444; color:#fff }

.bar-hidden {
  opacity: 0;
  pointer-events: none;
  transform: translateY(20px);
  transition: opacity 0.15s ease, transform 0.15s ease;
}

.bar-visible {
  opacity: 1;
  pointer-events: auto;
  transform: translateY(0);
  transition: opacity 0.15s ease, transform 0.15s ease;
}

/* Overlay universel pour toutes les fenêtres modales */
.modal-backdrop {
  position: fixed;
  inset: 0;
  background: rgba(0, 0, 0, 0.65);
  z-index: 999;
  display: none;
}

.modal-backdrop.dark {
  background: rgba(255, 255, 255, 0.15); /* Plus clair sur fond sombre */
}

.modal-backdrop.light {
  background: rgba(0, 0, 0, 0.45); /* Plus foncé sur fond clair */
}

.modal-backdrop.active {
  display: block;
}
/* Ajuster le z-index des overlays existants pour être au-dessus du backdrop */
#selectionOverlay,
#infoOverlay,
#gameModeOverlay,
#gamePlayOverlay {
  z-index: 1000;
}

/* =====================================================
   Reading page (fullscreen)
   ===================================================== */
#displayPage{
  display:none;
  position:fixed; inset:0;
  width:100%; height:100%; overflow:hidden;
  background:var(--card);
}

/* Character area */
#charContainer{
  position:relative;
  height:calc(100dvh - 110px);
  width:100%;
  display:flex; align-items:center; justify-content:center;
  padding:12px;
}

#charDisplay{
  display:flex; justify-content:center; align-items:baseline;
  gap:.12em; white-space:nowrap; line-height:1;
  font-family:"Noto Sans SC",sans-serif; font-weight:800;
}

#charDisplay span{ display:inline-flex; width:1em; justify-content:center; align-items:center; text-align:center }
#charDisplay .han, #charDisplay .punc{ font-weight:800 }
#charDisplay.shifted{ transform:translateX(.4em) }

#pinyin,#defs{
  position:absolute; left:50%; transform:translateX(-50%);
  text-align:center; width:100%; padding:0 12px;
}
#pinyin{ top:calc(50% + 12vh); font-size:clamp(22px,6.2vw,34px); font-weight:700 }
#defs{   top:calc(50% + 18vh); font-size:clamp(16px,4.4vw,24px); font-weight:600; color:#0f172ac7 }
#pinyin, #defs{ pointer-events:none }

/* Reading controls */
:root{
  --maxWidth: 760px;
  --safe: env(safe-area-inset-bottom, 0px);
  --gap:10px; --padX:12px; --slotH1:62px; --slotH2:54px; --radius:14px;
  --blur: 10px; --elev: 0 6px 20px rgba(0,0,0,.12);
  --alpha1:.18; --alpha2:.26; --stroke:.55;
}

.bar{ position:absolute; left:50%; transform:translateX(-50%); width:100%; max-width:var(--maxWidth); padding:0 var(--padX); display:flex; gap:var(--gap); }
.bar-default{ bottom: calc(var(--safe) + 0px); }

.slot{ 
  flex:1; display:flex; align-items:center; justify-content:center; border-radius: var(--radius);
  background: rgba(255,255,255,0.1);
  box-shadow: var(--elev);
  border:1px solid; cursor:pointer; user-select:none; height:var(--slotH1); 
}


.bottom-hit{ 
  position:absolute; 
  left:0; 
  right:0; 
  bottom:0; 
  height:72px; 
  display:none; 
  cursor:pointer; 
  z-index:2; 
}

.onLightBorder{ border-color: rgba(0,0,0,var(--stroke)); }
.onDarkBorder { border-color: rgba(255,255,255,var(--stroke)); }
.defOnLight { background: rgba(0,0,0,var(--alpha1)); color:#000; }
.defOnDark  { background: rgba(255,255,255,var(--alpha1)); color:#fff; }
.extOnLight { background: rgba(0,0,0,var(--alpha2)); color:#000; }
.extOnDark  { background: rgba(255,255,255,var(--alpha2)); color:#fff; }

.overlay-footer {
  flex-shrink: 0;
  display: flex;
  justify-content: flex-end;
  gap: 12px;
  padding: 12px 16px;
  border-top: 1px solid #e5e7eb;
  background: #f9fafb;
}

.overlay-footer .info-btn {
  appearance: none;
  border: none;
  border-radius: 12px;
  padding: 10px 16px;
  font-weight: 700;
  cursor: pointer;
}

.overlay-footer .info-cancel {
  background: #e5e7eb;
  color: #111827;
}

.overlay-footer .info-validate {
  background: #ef4444;
  color: #ffffff;
}

#selectionOverlay {
  position: fixed;
  inset: 0;
  z-index: 1000;
  display: none;
  align-items: center;
  justify-content: center;
  background: rgba(0,0,0,.45);
}

/* Info Overlay */
#infoOverlay{
  position:fixed; inset:0; z-index:1100;
  display:none; align-items:center; justify-content:center;
  padding:16px;
  background:rgba(0,0,0,.45);
}

#infoOverlay .info-card{
  width:100%; max-width:860px; max-height:86dvh;
  border-radius:14px; box-shadow:0 10px 28px rgba(0,0,0,.26);
  display:flex; flex-direction:column; overflow:hidden;
  background:var(--info-bg,#ffffff); color:var(--info-fg,#111);
}

#infoOverlay .info-header{
  display:flex; align-items:center; justify-content:space-between;
  padding:12px 16px; font-weight:800;
  background:color-mix(in oklab, var(--info-bg,#fff) 88%, #000 0%);
  border-bottom:1px solid color-mix(in oklab, var(--info-fg,#111) 10%, transparent);
}

#infoOverlay .info-close{
  background:transparent; border:none; font-size:20px; cursor:pointer; color:inherit;
}

#infoOverlay .info-body{
  padding:14px 14px 6px; overflow:auto; line-height:1.9;
}

.info-word {
  display:inline-block;
  margin:6px 6px;
  padding:8px 12px;
  border-radius:8px;
  font-family:"Noto Sans SC","Inter",sans-serif;
  font-weight:700;
  font-size:22px;
  background:color-mix(in oklab, var(--info-bg,#fff) 85%, #000 0%);
  color: var(--info-fg,#111);
  border:1px solid color-mix(in oklab, var(--info-fg,#111) 10%, transparent);
  user-select:none;
}

.info-word.selectable{ 
  cursor: pointer !important;
  pointer-events: auto !important; 
}

.info-word.current{
  outline: 2px solid color-mix(in oklab, var(--info-fg, #111) 40%, transparent);
  outline-offset: 2px; 
}

.info-word.chosen {
  background: #ef4444;
  color: #ffffff;
  border-color: rgba(255,255,255,0.25);
}

.info-word.initialSelected {
  color: #dc2626 !important;
  background: inherit;
  border: inherit;
}

#infoOverlay .info-footer{
  display:flex; gap:12px; justify-content:flex-end; padding:12px 16px;
  border-top:1px solid color-mix(in oklab, var(--info-fg,#111) 10%, transparent);
  background:color-mix(in oklab, var(--info-bg,#fff) 92%, #000 0%);
}

.info-btn{
  appearance:none; border:none; border-radius:12px; padding:12px 18px;
  font-weight:800; cursor:pointer;
}

.info-btn.info-cancel{
  background: color-mix(in oklab, var(--info-fg,#111) 10%, transparent);
  color: var(--info-fg,#111);
}

.info-btn.info-validate {
  background: #ef4444;
  color: #ffffff;
}

.info-word.initialSelected.chosen,
#segmentedOverlayText span.selected.initialSelected {
  background: #ef4444;
  color: #ffffff !important;
  border-color: rgba(255,255,255,0.25);
}

#hamburger {
  position: absolute;
  bottom: calc(env(safe-area-inset-bottom, 0px) + var(--slotH1) + 6px);
  right: var(--padX);
  transform: translateX(-50%);
  background: none;
  border: none;
  box-shadow: none;
  width: auto;
  height: auto;
  padding: 0;
}

#hamburger svg {
  width: 24px;
  height: 24px;
  fill: currentColor;
}

/* Game bars */
#gameBars {
  position: absolute;
  left: 50%;
  transform: translateX(-50%);
  bottom: calc(env(safe-area-inset-bottom, 0px) + 0px);
  width: 100%;
  max-width: 760px;
  padding: 0 12px;
  z-index: 2;
}

.game-bar {
  display: grid;
  grid-template-columns: 1fr 2fr 2fr 2fr 1fr;
  gap: 10px;
  height: 62px;
}

.game-btn {
  display: flex;
  align-items: center;
  justify-content: center;
  border-radius: 14px;
  border: none !important;
  backdrop-filter: saturate(120%) blur(10px);
  -webkit-backdrop-filter: saturate(120%) blur(10px);
  box-shadow: 0 6px 20px rgba(0,0,0,.12);
  cursor: pointer;
  transition: transform 0.1s ease;
}

.game-btn:active {
  transform: scale(0.98);
}

.game-btn .icon {
  width: 24px;
  height: 24px;
  display: block;
}

.game-btn#quitGameBtn {
  background: rgba(220, 38, 38, 0.2);
  color: #991b1b;
  border-color: rgba(220, 38, 38, 0.4);
}

.game-btn#prevSentenceBtn {
  background: rgba(59, 130, 246, 0.2);
  color: #1e40af;
  border-color: rgba(59, 130, 246, 0.4);
}

.game-btn#playGameBtn {
  background: rgba(34, 197, 94, 0.2);
  color: #166534;
  border-color: rgba(34, 197, 94, 0.4);
}

.game-btn#nextSentenceBtn {
  background: rgba(249, 115, 22, 0.2);
  color: #9a3412;
  border-color: rgba(249, 115, 22, 0.4);
}

.game-btn#showGameBtn {
  background: rgba(168, 85, 247, 0.2);
  color: #6b21a8;
  border-color: rgba(168, 85, 247, 0.4);
}

.game-btn#randomSentenceBtn {
  background: rgba(236, 72, 153, 0.2);
  color: #9f1239;
  border-color: rgba(236, 72, 153, 0.4);
}


.mode-switch.active {
  background: #ef4444 !important;
  color: white !important;
  border-color: #ef4444 !important;
}

.nav-btn-replay {
  background: rgba(34, 197, 94, 0.85);
  color: #ffffff;
  font-weight: 700;
  border: none !important;
}

.nav-btn-replay::before {
  content: '▶';
  margin-right: 6px;
  font-size: 12px;
}

.nav-btn-replay:hover {
  background: rgba(34, 197, 94, 0.95);
  transform: translateY(-1px);
}

#pinyinBars {
  position: fixed;
  left: 50%;
  transform: translateX(-50%);
  bottom: calc(env(safe-area-inset-bottom, 0px) + 0px);
  width: 100%;
  max-width: 760px;
  padding: 0 12px;
  z-index: 1001;
  top: auto;
}

/* Game overlays */
#gameModeOverlay,
#gamePlayOverlay {
  position: fixed;
  inset: 0;
  z-index: 1200;
  display: flex;
  align-items: center;
  justify-content: center;
  background: rgba(0,0,0,0.5);
  padding: 16px;
}

.game-overlay-content {
  width: 100%;
  max-width: 600px;
  max-height: 90vh;
  border-radius: 16px;
  overflow: hidden;
  box-shadow: 0 20px 50px rgba(0,0,0,0.3);
  display: flex;
  flex-direction: column;
}

.game-header {
  display: flex;
  justify-content: space-between;
  align-items: center;
  padding: 16px 20px;
  border-bottom: 1px solid rgba(0,0,0,0.1);
  background: rgba(0,0,0,0.05);
}

.game-header h3 {
  margin: 0;
  font-size: 18px;
  font-weight: 800;
}

.close-btn {
  background: none;
  border: none;
  font-size: 20px;
  cursor: pointer;
  color: inherit;
  padding: 4px;
}

.mode-buttons {
  display: flex;
  gap: 16px;
  justify-content: center;
  padding: 24px;
}

.mode-btn {
  background: rgba(239, 68, 68, 0.15);
  border: 2px solid rgba(239, 68, 68, 0.3);
  border-radius: 12px;
  padding: 16px 24px;
  font-size: 16px;
  font-weight: 700;
  cursor: pointer;
  transition: all 0.2s ease;
  color: #1f2937;
}

.mode-btn:hover {
  background: rgba(239, 68, 68, 0.25);
  border-color: rgba(239, 68, 68, 0.4);
  transform: translateY(-2px);
  box-shadow: 0 8px 20px rgba(239, 68, 68, 0.2);
}

.mode-switcher {
  display: flex;
  gap: 8px;
  justify-content: flex-start;
  padding: 12px 20px 16px; 
}

.mode-switcher .mode-switch {
  background: rgba(0,0,0,0.08);
  border: 2px solid rgba(0,0,0,0.2);
  border-radius: 10px;
  padding: 10px 20px;
  font-size: 15px;
  font-weight: 700;
  cursor: pointer;
  color: #1f2937;
  transition: all 0.2s ease;
  box-shadow: 0 2px 8px rgba(0,0,0,0.08);
}

.mode-switcher .mode-switch.active {
  background: #ef4444;
  color: white;
  border-color: #ef4444;
  box-shadow: 0 4px 12px rgba(239, 68, 68, 0.3);
  transform: translateY(-1px);
}

.mode-switcher .mode-switch:hover:not(.active) {
  background: rgba(0,0,0,0.12);
  border-color: rgba(0,0,0,0.3);
  transform: translateY(-1px);
}

.game-content {
  padding: 20px;
  flex: 1;
  overflow-y: auto;
  display: flex;
  flex-direction: column;
  align-items: center;   
}

.word-pool,
.sentence-builder {
  margin-bottom: 20px;
}

.pool-title {
  font-weight: 700;
  margin-bottom: 8px;
  color: inherit;
}

.words-container {
  min-height: 60px;
  padding: 12px;
  border: 2px dashed rgba(0,0,0,0.3);
  border-radius: 8px;
  display: flex;
  flex-wrap: wrap;
  gap: 8px;
  background: rgba(0,0,0,0.05);
}

.drop-zone {
  background: rgba(0,0,0,0.1);
}

.word-token {
  background: rgba(239, 68, 68, 0.15);
  border: 2px solid rgba(239, 68, 68, 0.3);
  border-radius: 8px;
  padding: 12px 16px;
  font-size: 22px;
  font-weight: 700;
  cursor: pointer;
  user-select: none;
  transition: all 0.2s ease;
  color: #000000;
  font-family: "Noto Sans SC", "Inter", sans-serif;
}

.word-token:hover {
  transform: translateY(-1px);
  box-shadow: 0 4px 12px rgba(0,0,0,0.15);
}

.word-token.dragging {
  opacity: 0.5;
  transform: rotate(2deg);
}


/* Le reste du CSS continue après */
.free-input-container {
  margin-bottom: 20px;
}
.free-input-container {
  margin-bottom: 20px;
}

.free-input-container label {
  display: block;
  font-weight: 700;
  margin-bottom: 8px;
  color: inherit;
}

.free-textarea {
  width: 100%;
  min-height: 120px;
  padding: 16px;
  border: 2px solid rgba(0,0,0,0.2);
  border-radius: 8px;
  font-size: 16px;
  font-family: "Noto Sans SC", "Inter", sans-serif;
  background: rgba(0,0,0,0.05);
  color: inherit;
  resize: vertical;
}

.free-textarea:focus {
  outline: none;
  border-color: #ef4444;
  box-shadow: 0 0 0 3px rgba(239, 68, 68, 0.2);
}

.validate-btn,
.retry-btn {
  background: #ef4444;
  color: white;
  border: none;
  border-radius: 8px;
  padding: 12px 24px;
  font-size: 16px;
  font-weight: 700;
  cursor: pointer;
  display: block;
  margin: 0 auto 16px;
  transition: all 0.2s ease;
}

.validate-btn:hover,
.retry-btn:hover {
  background: #dc2626;
  transform: translateY(-1px);
}

.retry-btn {
  background: #6b7280;
}

.retry-btn:hover {
  background: #4b5563;
}

.result-message {
  text-align: center;
  padding: 16px;
  margin: 16px 0;
  border-radius: 8px;
  font-weight: 700;
  font-size: 16px;
}

.result-message.success {
  background: rgba(34, 197, 94, 0.2);
  color: #000000;
  border: 1px solid rgba(34, 197, 94, 0.4);
}

.result-message.error {
  background: rgba(239, 68, 68, 0.2);
  color: #991b1b;
  border: 1px solid rgba(239, 68, 68, 0.4);
}

.game-nav-footer {
  display: flex;
  justify-content: space-between;
  gap: 12px;
  padding: 16px 20px;
  border-top: 1px solid rgba(0,0,0,0.1);
  background: rgba(0,0,0,0.05);
}

.nav-btn {
  background: rgba(0,0,0,0.1);
  border: 1px solid rgba(0,0,0,0.2);
  border-radius: 8px;
  padding: 10px 16px;
  font-size: 14px;
  font-weight: 600;
  cursor: pointer;
  color: inherit;
  transition: all 0.2s ease;
}

.nav-btn:hover {
  background: rgba(0,0,0,0.2);
}

.nav-btn:disabled {
  opacity: 0.5;
  cursor: not-allowed;
}

.game-mode-active .bar.bar-default {
  display: none !important;
}

.game-mode-active #ghostBar {
  display: none !important;
}

.bar.bar-default{
  position:absolute; left:50%; transform:translateX(-50%);
  bottom: calc(env(safe-area-inset-bottom, 0px) + 0px);
  width:100%; max-width:760px; padding:0 12px;
  display:grid; grid-template-columns: 1fr 2fr 2fr 2fr 1fr auto; gap: 10px;
}

.bar.bar-default .slot{
  height: 62px;
  display:flex; align-items:center; justify-content:center;
  border-radius:14px; border:1px solid;
  backdrop-filter: saturate(120%) blur(10px); -webkit-backdrop-filter: saturate(120%) blur(10px);
  box-shadow: 0 6px 20px rgba(0,0,0,.12);
}

.bar.bar-default .slot,
#hamburger {
  border: none !important;
  outline: none !important;
}

.bar.bar-default .icon{ width:24px; height:24px; display:block }

#ghostBar{
  position:absolute;
  left:50%;
  transform:translateX(-50%);
  bottom: calc(env(safe-area-inset-bottom, 0px) + 0px);
  width:100%;
  max-width:760px;
  padding:0 12px;
  display:none;
  grid-template-columns: 1fr 1fr 1fr;
  gap:10px;
  background:transparent;
  z-index:3;
}

#ghostBar button{
  height:62px;
  background:transparent;
  border:none;
  pointer-events:auto;
}

/* Cacher la barre de boutons quand l'overlay de jeu est ouvert */
body:has(#gamePlayOverlay[style*="display: flex"]) #gameBarsNoRead,
body:has(#gamePlayOverlay[style*="display: flex"]) #gameBars {
  display: none !important;
}

#hamburger{
  width:36px; height:36px;
  border-radius:999px; border:1px solid;
  display:flex; align-items:center; justify-content:center;
  background: transparent;
  box-shadow: 0 6px 20px rgba(0,0,0,.12);
}

.onLightBorder{ border-color: rgba(0,0,0,.55); }
.onDarkBorder { border-color: rgba(255,255,255,.55); }
.defOnLight { background: rgba(0,0,0,.18); color:#000; }
.defOnDark  { background: rgba(255,255,255,.18); color:#fff; }

/* === Mobile DnD only === */
@media (pointer: coarse) and (hover: none) {
  .words-container { position: relative; }
  .word-token { touch-action: none; } /* permet le suivi du doigt */
  .word-token.drag-source { visibility: hidden; }

  .drag-ghost {
    position: fixed;
    z-index: 10000;
    pointer-events: none;
    transform: translate(-50%, -50%) scale(0.96); /* petit scale pour voir derrière */
    opacity: .95;
    filter: drop-shadow(0 6px 18px rgba(0,0,0,.25));
    will-change: transform, left, top;
  }

  .placeholder-token {
    display: inline-block;
    min-width: 28px;
    border-radius: 10px;
    background: rgba(16,185,129,.14);   /* vert clair */
    border: 2px dashed rgba(16,185,129,.6);
    vertical-align: middle;
  }

  .drop-caret {
    position: fixed;
    z-index: 10001;
    width: 2px;
    background: #10B981; /* vert */
    border-radius: 1px;
  }

  /* feedback de zone cible */
  .words-container.drop-zone--active {
    border-color: rgba(59,130,246,.6);
    box-shadow: 0 0 0 3px rgba(59,130,246,.15) inset;
  }
}

/* Pinyin Game Mode */
#pinyinKeyboard {
  position: fixed;
  left: 50%;
  transform: translateX(-50%);
  bottom: calc(env(safe-area-inset-bottom, 0px) + 72px);
  width: 100%;
  max-width: 760px;
  padding: 16px;
  background: transparent !important;
  border-radius: 16px 16px 0 0;
  box-shadow: 0 -4px 20px rgba(0,0,0,0.15);
  display: none;
  z-index: 10;
}

.keyboard-row {
  display: flex;
  justify-content: center;
  gap: 6px;
  margin-bottom: 8px;
}

.key-btn {
  min-width: 36px;
  height: 44px;
  padding: 8px 12px;
  background: rgba(255,255,255,0.18);
  backdrop-filter: saturate(120%) blur(10px);
  border: none;;
  box-shadow: 0 6px 20px rgba(0,0,0,.12);
  border-radius: 8px;
  font-size: 18px;
  font-weight: 600;
  cursor: pointer;
  transition: all 0.1s ease;
  box-shadow: 0 2px 4px rgba(0,0,0,0.08);
}

.key-btn:hover {
  background: #f3f4f6;
  transform: translateY(-1px);
}

.key-btn:active {
  transform: translateY(0);
  box-shadow: 0 1px 2px rgba(0,0,0,0.08);
}

.key-btn.wide {
  min-width: 80px;
}

.key-btn.backspace {
  background: #fee2e2;
  color: #dc2626;
}

.key-btn.validate {
  background: #10b981;
  color: #ffffff;
  font-weight: 700;
}

/* Tone picker popup */
.tone-picker {
  position: absolute;
  background: #ffffff;
  border: 2px solid #3b82f6;
  border-radius: 12px;
  padding: 8px;
  display: none;
  flex-direction: column;
  gap: 4px;
  box-shadow: 0 8px 24px rgba(0,0,0,0.2);
  z-index: 100;
}

.tone-picker.active {
  display: flex;
}

.tone-option {
  padding: 8px 16px;
  font-size: 20px;
  font-weight: 600;
  background: #f9fafb;
  border: none;
  border-radius: 8px;
  cursor: pointer;
  transition: background 0.15s ease;
}

.tone-option:hover {
  background: #e5e7eb;
}

.tone-option.selected {
  outline: 2px solid currentColor;
  outline-offset: 2px;
  border-radius: 6px;
}

/* Pinyin input boxes above characters */
.pinyin-input-boxes {
  position: absolute;
  top: calc(50% - 22vh); 
  left: 50%;
  transform: translateX(-50%);
  display: flex;
  gap: 16px;
  align-items: center;
  justify-content: center;
}

.pinyin-box {
  min-width: 80px;  
  height: 70px; 
  padding: 12px 16px;  
  background: rgba(255,255,255,0.9);
  border: 2px solid #d1d5db;
  border-radius: 10px;
  font-size: 36px; 
  font-weight: 700;
  display: flex;
  align-items: center;
  justify-content: center;
  transition: all 0.2s ease;
}

.pinyin-box.active {
  border-color: #3b82f6;
  box-shadow: 0 0 0 3px rgba(59,130,246,0.2);
}

.pinyin-box.correct {
  color: #10b981;
  border-color: #10b981;
  background: rgba(16,185,129,0.1);
}

.pinyin-box.incorrect {
  color: #ef4444;
  border-color: #ef4444;
  background: rgba(239,68,68,0.1);
}

#pinyinSubOptions .opt {
  margin: 10px 0;
  gap: 10px; /* Réduire l'espace entre le toggle et le texte */
}

#pinyinSubOptions .opt input[type="checkbox"] {
  width: 44px;  /* Réduire la largeur du toggle */
  height: 26px; /* Réduire la hauteur du toggle */
}

#pinyinSubOptions .opt input[type="checkbox"]::after {
  width: 20px;  /* Réduire la taille de la boule */
  height: 20px;
  top: 3px;
  left: 3px;
}

#pinyinSubOptions .opt input[type="checkbox"]:checked::after {
  left: 21px;  /* Ajuster la position quand activé */
}

#pinyinSubOptions .opt span {
  font-size: 14px;      /* Même taille que .game-mode-item label */
  font-weight: 600;     /* Même poids */
  color: #374151;       /* Même couleur */
  font-family: "Inter", system-ui, Arial, sans-serif; /* Même police */
  line-height: 1.3;
}


/* Tone selection buttons */
#toneSelection {
  position: fixed;
  left: 50%;
  transform: translateX(-50%);
  bottom: calc(env(safe-area-inset-bottom, 0px) + 72px);
  width: 100%;
  max-width: 760px;
  padding: 16px;
  background: transparent;
  display: none;
  z-index: 10;
}

.tone-buttons {
  display: flex;
  flex-direction: column;
  gap: 10px;
  max-height: 300px;
  overflow-y: auto;
}

.tone-btn {
  padding: 16px 24px;
  background: #ffffff;
  border: 2px solid #d1d5db;
  border-radius: 12px;
  font-size: 22px;
  font-weight: 700;
  cursor: pointer;
  transition: all 0.15s ease;
  box-shadow: 0 2px 6px rgba(0,0,0,0.08);
  font-family: "Noto Sans SC", "Inter", sans-serif;
}

.tone-btn:hover {
  background: #f3f4f6;
  border-color: #9ca3af;
  transform: translateY(-1px);
}

.tone-btn:active {
  transform: scale(0.98);
}

/* Mode sombre */
body.dark-mode #pinyinKeyboard,
body.dark-mode #toneSelection {
  background: rgba(0,0,0,0.18);
}

.overlay-footer {
  flex-shrink: 0;
  display: flex;
  justify-content: space-between;
  align-items: center;
  gap: 12px;
  padding: 12px 16px;
  border-top: 1px solid #e5e7eb;
  background: #f9fafb;
}

#selectAllOverlay {
  display: flex;
}

.tone-btn {
  border: none;
  border-radius: 14px;
  font-size: 44px;
  font-weight: 700;
  cursor: pointer;
  transition: all 0.15s ease;
  backdrop-filter: saturate(120%) blur(10px);
  -webkit-backdrop-filter: saturate(120%) blur(10px);
  box-shadow: 0 6px 20px rgba(0,0,0,.12);
  display: flex;
  align-items: center;
  justify-content: center;
}

.tone-btn:hover {
  transform: scale(1.05);
}

.tone-btn:active {
  transform: scale(0.98);
}

/* Agrandir les accents sauf ˇ */
.pinyin-box {
  font-size: 28px;
}

.tone-btn:not(.tone-btn-bottom) {
  font-size: 44px;
}

/* Flash effect for keyboard */
.key-btn.flash {
  animation: keyFlash 0.2s ease;
}

@keyframes keyFlash {
  0%, 100% { background: rgba(255,255,255,0.18); }
  50% { background: rgba(59, 130, 246, 0.4); }
}

/* Highlight selected tone option */
.tone-option.selected {
  background: #3b82f6;
  color: white;
}

/* Cacher les barres de navigation sur la page d'accueil */
body:has(#homePage:not([style*="display: none"])) #pinyinBars,
body:has(#homePage:not([style*="display: none"])) #gameBars,
body:has(#homePage:not([style*="display: none"])) #gameBarsNoRead,
body:has(#homePage:not([style*="display: none"])) #barDefault {
  display: none !important;
}

@media (max-width:560px){
  :root{ --slotH1:58px; --slotH2:50px; --gap:8px; --padX:10px; }
}

@media (max-width:600px){
  .container{
    padding:max(10px, env(safe-area-inset-left)) max(10px, env(safe-area-inset-right));
  }
  .card{ padding:calc(var(--space) * .9) }
  .opt{ gap:14px }
  .swatch{ min-width:130px }
  .cta-bar .btn-primary{ width:100% }

  #controls .ctrl-btn{ width:56px; height:56px; font-size:26px }

  #charContainer{ height:calc(100dvh - 110px) }
  #charDisplay{ font-size:80px }
  #charDisplay.long-seq{ font-size:clamp(28px, 6vw, 40px) }

  #pinyin{ top:calc(50% + 8vh) }
  #defs{   top:calc(50% + 12vh) }
  
  .mode-buttons {
    flex-direction: column;
    align-items: center;
  }
  
  .mode-btn {
    width: 100%;
    max-width: 280px;
  }
  
  .game-nav-footer {
    flex-direction: column;
  }
  
  .game-bar {
    height: 54px;
  }
  
  .game-btn {
    font-size: 13px;
  }
  
  .mode-option {
    flex: 1 1 100%;
    max-width: none;
  }
  
  .mode-selector {
    flex-direction: column;
  }

  .tone-cross-container {
    transform: translateY(28px) !important;
  }
  
/* --- Clavier Pinyin : rangées fixes + centrage parfait --- */

/* Conteneur clavier */
#pinyinKeyboard{
  width: 94%;
  padding: 10px 6px;
  left: 50%;
  transform: translateX(-50%);
}

/* 1ère & 2e rangées : 10 colonnes identiques */
#pinyinKeyboard .keyboard-row:nth-of-type(1),
#pinyinKeyboard .keyboard-row:nth-of-type(2){
  display: grid;
  grid-template-columns: repeat(10, minmax(0,1fr));
  gap: 4px;
}

/* 3e rangée : 10 colonnes aussi, mais on centre 6 touches
   grâce à deux “espacers” virtuels de 2 colonnes à gauche/droite */
#pinyinKeyboard .keyboard-row:nth-of-type(3){
  display: grid;
  grid-template-columns: repeat(10, minmax(0,1fr));
  gap: 4px;
  position: relative;
}

/* spacers gauche/droite (2 colonnes chacun) pour centrer w x c v b n */
#pinyinKeyboard .keyboard-row:nth-of-type(3)::before,
#pinyinKeyboard .keyboard-row:nth-of-type(3)::after{
  content: "";
  display: block;
}

#pinyinKeyboard .keyboard-row:nth-of-type(3)::before{ grid-column: 1 / span 2; }
#pinyinKeyboard .keyboard-row:nth-of-type(3)::after { grid-column: 9 / span 2; }

/* chaque touche occupe 1 colonne (les 6 lettres tomberont au centre) */
#pinyinKeyboard .keyboard-row:nth-of-type(3) .key-btn{
  grid-column: auto / span 1;
}

/* Touches : même taille partout + centrage strict du contenu */
#pinyinKeyboard .key-btn{
  min-width: 0;
  width: 100%;
  height: 40px;            /* ajuste à 38px si tu veux plus compact */
  font-size: 16px;
  box-sizing: border-box;

  display: flex;           /* centrage parfait */
  align-items: center;
  justify-content: center;
  line-height: 1;          /* évite le décalage vertical du texte */
  padding: 0;              /* supprime marges internes parasites */
}

/* Icônes SVG (retour, valider…) parfaitement centrées */
#pinyinKeyboard .key-btn svg{
  display: block;
  height: 1em;
  width: 1em;
}

/* (si tu as des touches “larges”) */
#pinyinKeyboard .key-btn.wide{
  grid-column: span 2;
}

</style>
</head>

<body>
  <div class="container">
    <div class="card" id="homePage">
      <h1>Lecteur chinois mot-à-mot</h1>

      <!-- Mode Selector -->
      <div class="mode-selector">
        <div class="mode-option">
          <input type="radio" id="readMode" name="appMode" value="read" checked>
          <label class="mode-label" for="readMode">
            <div class="mode-icon">📖</div>
            <div class="mode-title">Mode Lecture</div>
            <div class="mode-desc">Lecture avec sélection de mots</div>
          </label>
        </div>
        <div class="mode-option">
          <input type="radio" id="gameMode" name="appMode" value="game">
          <label class="mode-label" for="gameMode">
            <div class="mode-icon">🎮</div>
            <div class="mode-title">Mode Jeu</div>
            <div class="mode-desc">Exercices interactifs</div>
          </label>
        </div>
      </div>

      <div class="input-wrap">
        <div id="editorArea">
          <textarea id="inputText">你好，我们是学生。老师喜欢中国。</textarea>
        </div>
        <div id="segmentedArea" style="display:none;">
          <div id="segmentedText" class="segmented-box"></div>
        </div>
<div class="editor-actions">
  <button id="clearText" class="editor-btn" title="Effacer le texte">
    <svg viewBox="0 0 24 24" class="icon" xmlns="http://www.w3.org/2000/svg">
      <line x1="18" y1="6" x2="6" y2="18" stroke-width="2" stroke-linecap="round"/>
      <line x1="6" y1="6" x2="18" y2="18" stroke-width="2" stroke-linecap="round"/>
    </svg>
  </button>
  
  <button id="selectAllWords" class="editor-btn" title="Tout sélectionner / désélectionner" style="display:none;">
    <svg viewBox="0 0 24 24" class="icon" xmlns="http://www.w3.org/2000/svg">
      <path d="M9 11l3 3L22 4" stroke="currentColor" stroke-width="2" fill="none" stroke-linecap="round" stroke-linejoin="round"/>
      <path d="M21 12v7a2 2 0 01-2 2H5a2 2 0 01-2-2V5a2 2 0 012-2h11" stroke="currentColor" stroke-width="2" fill="none" stroke-linecap="round" stroke-linejoin="round"/>
    </svg>
  </button>
  
  <button id="toggleEdit" class="editor-btn" title="Basculer édition/segmentation" style="display:none;">
    <svg viewBox="0 0 24 24" class="icon" xmlns="http://www.w3.org/2000/svg">
      <path d="M3 17.25V21h3.75L17.81 9.94l-3.75-3.75L3 17.25z"/>
      <path d="M20.71 7.04a1.003 1.003 0 0 0 0-1.42l-2.34-2.34a1.003 
                   1.003 0 0 0-1.42 0l-1.83 1.83 3.75 3.75 1.84-1.82z"/>
    </svg>
  </button>
</div>

      <!-- Game Mode Options -->
<div class="game-mode-options" id="gameModeOptions">
  <div class="game-mode-title">Options du mode jeu :</div>
  <div class="game-mode-grid">
    <div class="game-mode-item">
      <input type="radio" id="gameBoth" name="gameType" value="both" checked>
      <label for="gameBoth">Normal</label>
    </div>
    <div class="game-mode-item">
      <input type="radio" id="gameReorderNoRead" name="gameType" value="reorderNoRead">
      <label for="gameReorderNoRead">Phrases aléatoires</label>
    </div>
    <div class="game-mode-item">
      <input type="radio" id="gamePinyinKeyboard" name="gameType" value="pinyinKeyboard">
      <label for="gamePinyinKeyboard">Pinyin - Clavier</label>
    </div>
    <div class="game-mode-item">
      <input type="radio" id="gamePinyinToneLetters" name="gameType" value="pinyinToneLetters">
      <label for="gamePinyinToneLetters">Pinyin - Tons + Lettres</label>
    </div>
    <div class="game-mode-item">
      <input type="radio" id="gamePinyinTone" name="gameType" value="pinyinTone">
      <label for="gamePinyinTone">Pinyin - Tons seuls</label>
    </div>
  </div>
</div>

<div id="pinyinSubOptions" class="game-mode-options" style="display:none;margin-top:12px;">
  <div class="game-mode-title">Options Pinyin</div>
  <div class="game-mode-grid">
    <div class="game-mode-item">
      <input type="radio" id="pinyinFlowSelectedOnly" name="pinyinFlow" value="selectedOnly" checked>
      <label for="pinyinFlowSelectedOnly">
        Uniquement les mots sélectionnés
        <small style="display:block;opacity:.8">Séquence de quiz Pinyin mot par mot (barre Pinyin).</small>
      </label>
    </div>
    <div class="game-mode-item">
      <input type="radio" id="pinyinFlowStop" name="pinyinFlow" value="stopOnSelected">
      <label for="pinyinFlowStop">
        Lecture + arrêt sur mots sélectionnés
        <small style="display:block;opacity:.8">Barre du lecteur, pause auto sur chaque mot sélectionné, puis reprise.</small>
      </label>
    </div>
  </div>
</div>

      <fieldset>
        <legend>Paramètres de lecture</legend>
        <div id="speedControl">
  <label>Vitesse (mots/min) : <strong id="speedLabel">120</strong></label>
  <input class="range" type="range" id="speed" min="30" max="360" step="10" value="120">
</div>
        <div class="opt" id="pinyinOption">
          <input type="checkbox" id="showPinyin"><span>Afficher le pinyin</span>
        </div>
        <div class="opt" id="translationOption">
          <input type="checkbox" id="showDefs"><span>Afficher la traduction</span>
        </div>
        <div class="opt" id="selectionOption">
  <input type="checkbox" id="alwaysShowSelected" checked>
  <span>Tout afficher sur la sélection</span>
</div>
      </fieldset>

      <fieldset>
        <legend>Couleurs</legend>
        <div class="color-row">
          <div class="swatch">
            <div id="bgColorPicker"></div>
            <label for="bgColorPicker">Fond</label>
          </div>
          <div class="swatch">
            <div id="textColorPicker"></div>
            <label for="textColorPicker">Mots</label>
          </div>
          <div class="swatch" id="highlightBgSwatch">
            <div id="highlightBgColorPicker"></div>
            <label for="highlightBgColorPicker">Fond 2</label>
          </div>
          <div class="swatch" id="highlightColorSwatch">
            <div id="highlightColorPicker"></div>
            <label for="highlightColorPicker">Mots 2</label>
          </div>
        </div>
      </fieldset>

      <fieldset>
        <legend>Dictionnaire</legend>
        <button class="btn-ghost" id="loadDict">Charger CC-CEDICT</button>
        <input type="file" id="dictFile" accept=".u8,.txt" style="display:none">
        <span id="dictStatus" style="margin-left:8px;color:var(--muted)">Aucun dictionnaire chargé</span>
      </fieldset>

      <div class="cta-bar">
        <button class="btn-primary" id="startBtn">▶ Démarrer la lecture</button>
      </div>
    </div>
  </div>

  <!-- Selection Overlay -->
  <div id="selectionOverlay">
    <div class="overlay-content">
      <div id="overlayHeader">
        <button id="closeOverlay" aria-label="Fermer la sélection">✖</button>
      </div>
      <div id="segmentedOverlayText"></div>
<div class="overlay-footer">
  <button id="selectAllOverlay" class="info-btn info-cancel">
    <svg viewBox="0 0 24 24" class="icon" style="width:16px;height:16px;margin-right:6px" xmlns="http://www.w3.org/2000/svg">
      <path d="M9 11l3 3L22 4" stroke="currentColor" stroke-width="2" fill="none" stroke-linecap="round" stroke-linejoin="round"/>
      <path d="M21 12v7a2 2 0 01-2 2H5a2 2 0 01-2-2V5a2 2 0 012-2h11" stroke="currentColor" stroke-width="2" fill="none" stroke-linecap="round" stroke-linejoin="round"/>
    </svg>
    Tout sélectionner
  </button>
  <div style="flex:1"></div>
  <button id="overlayCancelBtn" class="info-btn info-cancel">Annuler</button>
  <button id="overlayValidateBtn" class="info-btn info-validate">Valider</button>
</div>
    </div>
  </div>
  
  <!-- Info Overlay -->
  <div id="infoOverlay" style="display:none">
    <div class="info-card">
      <div class="info-header">
        <strong>Aperçu du texte</strong>
        <button class="info-close" id="infoCloseBtn" aria-label="Fermer">✖</button>
      </div>
      <div class="info-body" id="infoWords"></div>
      <div class="info-footer">
        <button class="info-btn info-cancel" id="infoCancelBtn">Annuler</button>
        <button class="info-btn info-validate" id="infoValidateBtn">Valider</button>
      </div>
    </div>
  </div>

  <!-- Display Page -->
  <div id="displayPage">
    <div id="charContainer">
      <div id="charDisplay"></div>
      <div id="pinyin"></div>
      <div id="defs"></div>
    </div>

    <!-- Normal Bar -->
    <div class="bar bar-default" id="barDefault" aria-label="Menu de base">
      <button class="slot slot-quit" id="quitBtn" title="Quitter" aria-label="Quitter">
        <svg class="icon" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round">
          <line x1="18" y1="6" x2="6" y2="18"></line>
          <line x1="6"  y1="6" x2="18" y2="18"></line>
        </svg>
      </button>
      <button class="slot slot-prev" id="prevWordBtn" title="Mot précédent" aria-label="Mot précédent">
        <svg class="icon" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round">
          <polyline points="15 18 9 12 15 6"></polyline>
        </svg>
      </button>
      <button class="slot slot-play" id="pauseBtn" title="Lecture/Pause" aria-label="Lecture/Pause">
        <svg id="pauseIcon" class="icon" viewBox="0 0 24 24" fill="currentColor">
          <polygon points="8,6 18,12 8,18"></polygon>
        </svg>
      </button>
      <button class="slot slot-next" id="nextWordBtn" title="Mot suivant" aria-label="Mot suivant">
        <svg class="icon" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round">
          <polyline points="9 18 15 12 9 6"></polyline>
        </svg>
      </button>
      <button class="slot slot-info" id="infoBtn" title="Infos" aria-label="Infos">
        <svg class="icon" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round">
          <line x1="12" y1="17" x2="12" y2="11"></line>
          <line x1="12" y1="7"  x2="12" y2="7"></line>
        </svg>
      </button>
      <button class="slot slot-hamburger" id="hamburger" title="Afficher/Masquer le menu">
        <svg class="icon" viewBox="0 0 24 24" fill="currentColor">
          <path d="M4 7h16v2H4zm0 5h16v2H4zm0 5h16v2H4z"/>
        </svg>
      </button>
    </div>

    <!-- Ghost Bar -->
    <div id="ghostBar" aria-hidden="true" inert>
      <button id="ghostPrev"  aria-label="Mot précédent"></button>
      <button id="ghostPause" aria-label="Lecture/Pause"></button>
      <button id="ghostNext"  aria-label="Mot suivant"></button>
    </div>

    <!-- Game Bars -->
    <div id="gameBars" style="display:none;">
      <div class="game-bar">
        <button class="game-btn" id="quitGameBtn" title="Quitter le mode jeu" aria-label="Quitter">
          <svg class="icon" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round">
            <line x1="18" y1="6" x2="6" y2="18"></line>
            <line x1="6"  y1="6" x2="18" y2="18"></line>
          </svg>
        </button>
        <button class="game-btn" id="prevSentenceBtn" title="Phrase précédente" aria-label="Phrase précédente">
          <svg class="icon" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round">
            <polyline points="15 18 9 12 15 6"></polyline>
          </svg>
        </button>
        <button class="game-btn" id="playGameBtn" title="Lire la phrase" aria-label="Lecture">
          <svg class="icon" viewBox="0 0 24 24" fill="currentColor">
            <polygon points="8,6 18,12 8,18"></polygon>
          </svg>
        </button>
        <button class="game-btn" id="nextSentenceBtn" title="Phrase suivante" aria-label="Phrase suivante">
          <svg class="icon" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round">
            <polyline points="9 18 15 12 9 6"></polyline>
          </svg>
        </button>
        <button class="game-btn" id="showGameBtn" title="Afficher le jeu" aria-label="Jeu">
          <svg class="icon" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round">
            <line x1="12" y1="17" x2="12" y2="11"></line>
            <line x1="12" y1="7"  x2="12" y2="7"></line>
          </svg>
        </button>
      </div>
    </div>

    <!-- Game Bars No Read -->
    <div id="gameBarsNoRead" style="display:none;">
      <div class="game-bar">
        <button class="game-btn" id="quitGameNoReadBtn" title="Quitter le mode jeu" aria-label="Quitter">
          <svg class="icon" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round">
            <line x1="18" y1="6" x2="6" y2="18"></line>
            <line x1="6"  y1="6" x2="18" y2="18"></line>
          </svg>
        </button>
        <button class="game-btn" id="prevSentenceNoReadBtn" title="Phrase précédente" aria-label="Phrase précédente">
          <svg class="icon" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round">
            <polyline points="15 18 9 12 15 6"></polyline>
          </svg>
        </button>
        <button class="game-btn" id="randomSentenceBtn" title="Phrase aléatoire" aria-label="Aléatoire">
          <svg class="icon" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round">
            <path d="M16 3h5v5M4 20L21 3M21 16v5h-5M15 15l6 6M4 4l5 5"/>
          </svg>
        </button>
        <button class="game-btn" id="nextSentenceNoReadBtn" title="Phrase suivante" aria-label="Phrase suivante">
          <svg class="icon" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round">
            <polyline points="9 18 15 12 9 6"></polyline>
          </svg>
        </button>
        <button class="game-btn" id="showGameNoReadBtn" title="Afficher le jeu" aria-label="Jeu">
          <svg class="icon" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round">
            <line x1="12" y1="17" x2="12" y2="11"></line>
            <line x1="12" y1="7"  x2="12" y2="7"></line>
          </svg>
        </button>
      </div>
    </div>
  </div>
  
  <!-- Pinyin Bars -->
<div id="pinyinBars" style="display:none;">
  <div class="game-bar">
    <button class="game-btn" id="quitPinyinBtn" title="Quitter le mode pinyin" aria-label="Quitter">
      <svg class="icon" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round">
        <line x1="18" y1="6" x2="6" y2="18"></line>
        <line x1="6"  y1="6" x2="18" y2="18"></line>
      </svg>
    </button>
    <button class="game-btn" id="prevPinyinWordBtn" title="Mot précédent" aria-label="Mot précédent">
      <svg class="icon" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round">
        <polyline points="15 18 9 12 15 6"></polyline>
      </svg>
    </button>
    <button class="game-btn" id="playPinyinBtn" title="Lire le mot" aria-label="Lecture" style="visibility: hidden;">
      <svg class="icon" viewBox="0 0 24 24" fill="currentColor">
        <polygon points="8,6 18,12 8,18"></polygon>
      </svg>
    </button>
    <button class="game-btn" id="nextPinyinWordBtn" title="Mot suivant" aria-label="Mot suivant">
      <svg class="icon" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round">
        <polyline points="9 18 15 12 9 6"></polyline>
      </svg>
    </button>
    <button class="game-btn" id="showPinyinInfoBtn" title="Afficher les infos" aria-label="Infos">
      <svg class="icon" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round">
        <line x1="12" y1="17" x2="12" y2="11"></line>
        <line x1="12" y1="7"  x2="12" y2="7"></line>
      </svg>
    </button>
  </div>
</div>
 

  <!-- Game Mode Overlay -->
  <div id="gameModeOverlay" style="display:none;">
    <div class="game-overlay-content">
      <div class="game-header">
        <h3>Choisissez votre mode</h3>
        <button id="closeGameMode" class="close-btn">✖</button>
      </div>
      <div class="mode-buttons">
        <button id="reorderModeBtn" class="mode-btn">Réorganiser</button>
        <button id="freeModeBtn" class="mode-btn">Libre</button>
      </div>
      <div class="game-nav-footer">
        <button id="prevSentenceGame" class="nav-btn">← Précédente</button>
        <button id="replayGame" class="nav-btn nav-btn-replay">Relire</button>
        <button id="nextSentenceGame" class="nav-btn">Suivante →</button>
      </div>
    </div>
  </div>

  <!-- Game Play Overlay -->
<div id="gamePlayOverlay" style="display:none;">
  <div class="game-overlay-content">
    <div class="game-header">
      <h3>Exercice</h3>
      <button id="closeGamePlay" class="close-btn">✖</button>
    </div>

    <div class="mode-switcher">
      <button id="switchReorder" class="mode-switch active">Réorganiser</button>
      <button id="switchFree" class="mode-switch">Libre</button>
    </div>

    <div id="reorderGame" class="game-content">
      <div id="wordPool" class="word-pool">
        <div class="pool-title">Mots disponibles :</div>
        <div id="availableWords" class="words-container"></div>
      </div>
      <div id="sentenceBuilder" class="sentence-builder">
        <div class="pool-title">Votre phrase :</div>
        <div id="userSentence" class="words-container drop-zone"></div>
      </div>
      <button id="validateReorder" class="validate-btn">Valider</button>
      <div id="reorderResult" class="result-message" style="display:none;"></div>
      <button id="retryReorder" class="retry-btn" style="display:none;">Recommencer</button>
    </div>
    
    <div id="freeGame" class="game-content" style="display:none;">
      <div class="free-input-container">
        <label for="freeTextInput">Retapez la phrase :</label>
        <textarea id="freeTextInput" class="free-textarea" placeholder="Tapez la phrase ici..."></textarea>
      </div>
      <button id="validateFree" class="validate-btn">Valider</button>
      <div id="freeResult" class="result-message" style="display:none;"></div>
      <button id="retryFree" class="retry-btn" style="display:none;">Recommencer</button>
    </div>
    
    <div class="game-nav-footer">
      <button id="prevSentenceInGame" class="nav-btn">← Précédente</button>
      <button id="replayInGame" class="nav-btn nav-btn-replay">Relire</button>
      <button id="nextSentenceInGame" class="nav-btn">Suivante →</button>
    </div>
  </div>
</div>

<!-- Modal Backdrop Universal -->
<div id="modalBackdrop" class="modal-backdrop"></div>

</body>

<script>
// ========= État global =========
let dict = { entries: new Map(), wordSet: new Set(), maxLen: 1 };
let tokens = [];
let idx = 0;
let timer = null;
let playing = false;
let highlightWords = [];
let currentToken = null;
let editMode = true;
let infoChosenIndex = null;
let infoWasPlaying  = false;
let __menuHiddenByUser = false;
let gameMode = false;
let gameType = 'both';
let sentenceStarts = [];
let currentSentenceIndex = 0;
let originalSentence = '';
let currentGameMode = 'reorder';
let appMode = 'read';
let playedSentences = [];  // Pour tracker les phrases déjà jouées
let pinyinMode = 'keyboard';
let pinyinFlow = 'selectedOnly'; // 'stopOnSelected' | 'selectedOnly'
let pinyinGateActive = false;
 // 'keyboard', 'toneWithLetters', 'toneOnly'
let pinyinSelectedWords = []; // Mots sélectionnés pour le test pinyin
let currentPinyinWordIndex = 0; // Index dans les mots sélectionnés
let currentCharacterIndex = 0; // Index du caractère dans le mot actuel
let pinyinInput = []; // Saisie en cours pour chaque caractère
let pinyinValidated = false; // Si le mot actuel est validé
let selectedToneIndex = 0; // Index de l'option sélectionnée dans le tone picker
let isSelectingUorU = false; // Si on est en train de choisir entre u et ü
let autoNextTimer = null;
let showDefsTimer = null;
let tonePickerOpen = false;
let pendingVowel = null;     // 'a','e','i','o','u','ü'
let uChoiceOpen = false;     // sélection u / ü en cours ?

function showBackdrop() {
  const backdrop = document.getElementById('modalBackdrop');
  if (!backdrop) return;
  
  // Détecter la couleur de fond actuelle
  const bgColor = (bgColorPicker?.getColor()?.toHEXA().toString()) || '#ffffff';
  const isLightBg = getContrastingColor(bgColor) === '#000000';
  
  // Appliquer la classe appropriée
  backdrop.classList.remove('light', 'dark');
  backdrop.classList.add(isLightBg ? 'light' : 'dark');
  backdrop.classList.add('active');
}
function hideBackdrop() {
  const backdrop = document.getElementById('modalBackdrop');
  if (backdrop) {
    backdrop.classList.remove('active', 'light', 'dark');
  }
}


// ========= Utilitaires =========
function numericToDiacriticPinyin(pinyin){
  const toneMarks={a:['ā','á','ǎ','à'],e:['ē','é','ě','è'],i:['ī','í','ǐ','ì'],o:['ō','ó','ǒ','ò'],u:['ū','ú','ǔ','ù'],ü:['ǖ','ǘ','ǚ','ǜ']};
  function applyMark(s,tIndex){
    for(const l of ['a','o','e']){const i=s.toLowerCase().indexOf(l); if(i!==-1) return s.slice(0,i)+toneMarks[l][tIndex]+s.slice(i+1);}
    for(let i=s.length-1;i>=0;i--){const c=s[i].toLowerCase(); if(toneMarks[c]) return s.slice(0,i)+toneMarks[c][tIndex]+s.slice(i+1);}
    return s;
  }
  const normalized=pinyin.replace(/u:/g,'ü').replace(/U:/g,'Ü').replace(/\bv/g,'ü').replace(/\bV/g,'Ü');
  return normalized.replace(/([A-Za-zü:]+)([0-5])/g,(m,sy,t)=>{const tone=+t; if(tone===0||tone===5) return sy.replace(/:/g,''); return applyMark(sy,tone-1);});
}

function normalizeChineseText(text) {
  if (!text) return '';
  // Caractères invisibles
  text = text.replace(/[\u200B-\u200D\uFEFF]/g, '');
  // Normaliser retours à la ligne
  text = text.replace(/\r\n?/g, '\n');
  text = text.replace(/\n+/g, ' ');
  // Supprimer espaces entre caractères chinois
  text = text.replace(/([\p{Script=Han}])\p{White_Space}+(?=[\p{Script=Han}])/gu, '$1');
  // Supprimer espaces autour de la ponctuation
  const punct = '，。！？、；：,.!?;"《》『』「」〔〕【】（）﹁﹂﹃﹄';
  text = text.replace(new RegExp(`\\p{White_Space}+([${punct}])`, 'gu'), '$1');
  text = text.replace(new RegExp(`([${punct}])\\p{White_Space}+`, 'gu'), '$1');
  // Trim final
  return text.trim();
}

function parseCedict(raw){
  const entries=new Map(), wordSet=new Set(); let maxLen=1;
  for(const line of raw.split(/\r?\n/)){
    const L=line.trim(); if(!L||L.startsWith("#")) continue;
    const m=L.match(/^(\S+)\s+(\S+)\s+\[([^\]]+)\]\s+\/(.+)\/$/); if(!m) continue;
    const simp=m[2], pinyin=numericToDiacriticPinyin(m[3]), defs=m[4].split("/").map(d=>numericToDiacriticPinyin(d.trim())).filter(Boolean);
    if(!entries.has(simp)) entries.set(simp,{simp, pinyin, defs});
    wordSet.add(simp); if(simp.length>maxLen) maxLen=simp.length;
  }
  return { entries, wordSet, maxLen };
}

const isHan = ch => /[\u3400-\u9FFF\uF900-\uFAFF]/.test(ch);

function segmentText(text, wordSet, maxLen){
  const OPEN  = /["'«《「『（(〈]/u;
  const CLOSE = /["'»》」』）)〉]/u;
  const PUNC  = /[，、：；。！？,.!?;…—\-·•‥，？]/u;

  const isOpen   = ch => OPEN.test(ch);
  const isAfter  = ch => CLOSE.test(ch) || PUNC.test(ch);

  const result = [];
  let i = 0;
  let prefix = "";

  while (i < text.length){
    let ch = text[i];
    if (/\s/.test(ch)) { i++; continue; }
    if (isOpen(ch)) { prefix += ch; i++; continue; }

    let match = null;
    let len = Math.min(maxLen, text.length - i);
    while (len > 0){
      const cand = text.substr(i, len);
      if (wordSet.has(cand)) { match = cand; break; }
      len--;
    }

    if (match){
      result.push({ text: prefix + match, type:'han' });
      prefix = "";
      i += match.length;
      while (i < text.length && isAfter(text[i])) {
        result[result.length - 1].text += text[i];
        i++;
      }
      continue;
    }

    ch = text[i];
    if (isAfter(ch)) {
      if (result.length) result[result.length - 1].text += (prefix + ch);
      else result.push({ text: prefix + ch, type: 'punc' });
      prefix = ""; i++; continue;
    }

    result.push({ text: prefix + ch, type: /[\u3400-\u9FFF\uF900-\uFAFF]/.test(ch) ? 'han' : 'punc' });
    prefix = ""; i++;
  }

  if (prefix){
    if (result.length) result[result.length - 1].text = prefix + result[result.length - 1].text;
    else result.push({ text: prefix, type: 'punc' });
  }
  return result;
}

function attachDictInfo(tokens, dictMap){
  return tokens.map(tok=>{
    if(tok.type==='han'){
      const clean = stripPunct(tok.text);
      const e=dictMap.get(clean);
      if(e) return {...tok, pinyin:e.pinyin, defs:e.defs};
    }
    return tok;
  });
}

// ========= Rendu (accueil) =========
// ========= Rendu (accueil) =========
function renderSegmented(){
  const text = normalizeChineseText(document.getElementById('inputText').value);
  const segmented = attachDictInfo(segmentText(text, dict.wordSet, dict.maxLen), dict.entries);
  const c = document.getElementById('segmentedText'); 
  c.innerHTML = '';

  segmented.forEach((tok, i) => {
    const el = document.createElement('span');
    el.className = 'token';
    el.textContent = tok.text;

    const clean = stripPunct(tok.text);
    if (highlightWords.includes(clean)) el.classList.add('selected');

    el.addEventListener('click', (e) => {
      e.stopPropagation();
      if (highlightWords.includes(clean)) {
        highlightWords = highlightWords.filter(w => w !== clean);
      } else {
        highlightWords.push(clean);
      }
      renderSegmented();
      showToken(tok);
    });

    const play = document.createElement('button');
    play.className = 'chip-play';
    play.textContent = '▶';
    play.title = 'Lire à partir de ce mot';
    play.addEventListener('click', (e) => {
      e.stopPropagation();
      document.getElementById('homePage').style.display = 'none';
      const dp = document.getElementById('displayPage');
      dp.style.display = 'block';
      dp.style.visibility = 'visible';
      restartFrom(i);
      if (isPinyinGameMode() && pinyinFlow === 'selectedOnly') {
        forcePause();
      } else {
        forcePlay();
      }
    });
    
    c.appendChild(el);  // ← AJOUT : ajouter l'élément au conteneur
  });  
}  


// ========= Rendu (page de jeu) =========
function showToken(token) {
  currentToken = token;

  const cd   = document.getElementById('charDisplay');
  const pEl  = document.getElementById('pinyin');
  const dEl  = document.getElementById('defs');
  const cont = document.getElementById('charContainer');

cd.innerHTML = '';
// Nettoyer et masquer immédiatement pinyin/traduction
pEl.textContent = '';
dEl.textContent = '';
pEl.style.display = 'none';
dEl.style.display = 'none';

  let han = token.text, punc = '';
  if (/[。！？,.，!?]$/.test(token.text)) {
    han  = token.text.slice(0, -1);
    punc = token.text.slice(-1);
  }

  if (han) {
    for (const ch of han) {
      const s = document.createElement('span');
      s.className = 'han';
      s.textContent = ch;
      cd.appendChild(s);
    }
  }
  if (punc) {
    const sp = document.createElement('span');
    sp.className = 'punc';
    sp.textContent = punc;
    cd.appendChild(sp);
    cd.classList.add('shifted');
  } else {
    cd.classList.remove('shifted');
  }

const normalBg      = (bgColorPicker?.getColor()?.toHEXA().toString())          || '#ffffff';
const normalText    = (textColorPicker?.getColor()?.toHEXA().toString())        || '#000000';
const highlightBg   = (highlightBgColorPicker?.getColor()?.toHEXA().toString()) || '#000000';
const highlightText = (highlightColorPicker?.getColor()?.toHEXA().toString())   || '#ffffff';

const clean = stripPunct(token.text);
const isH   = highlightWords.includes(clean);

let pageBg, textCol;

if (gameMode) {
  // En mode jeu, toujours utiliser les couleurs normales
  pageBg = normalBg;
  textCol = normalText;
} else {
  // En mode lecture, différencier les mots surlignés
  pageBg = isH ? highlightBg : normalBg;
  textCol = isH ? highlightText : normalText;
}

  cd.style.color = textCol;
  const dp = document.getElementById('displayPage');
  dp.style.backgroundColor = pageBg;
  applyControlsTheme(getContrastingColor(pageBg));

  const contrast = getContrastingColor(pageBg);
  pEl.style.color = contrast;
  dEl.style.color = contrast;

  if (token.pinyin) pEl.textContent = token.pinyin;
  if (token.defs)   dEl.textContent = token.defs.join(', ');

  const optShowPinyin = !!document.getElementById('showPinyin')?.checked;
  const optShowDefs   = !!document.getElementById('showDefs')?.checked;
  const alwaysShowSel = !!document.getElementById('alwaysShowSelected')?.checked;

  // Forcer à masquer pour les modes spécifiques
  const gameTypeValue = document.querySelector('input[name="gameType"]:checked')?.value || 'both';
  const shouldForceHide = gameMode && (gameTypeValue === 'reorderNoRead' || gameTypeValue.includes('pinyin'));

  if (alwaysShowSel && isH) {
    pEl.style.display = shouldForceHide ? 'none' : '';
    dEl.style.display = shouldForceHide ? 'none' : '';
  } else {
    pEl.style.display = (optShowPinyin && !shouldForceHide) ? '' : 'none';
    dEl.style.display = (optShowDefs && !shouldForceHide) ? '' : 'none';
  }

  const totalLen = han.length + (punc ? 1 : 0);
  if (totalLen >= 5) cd.classList.add('long-seq'); else cd.classList.remove('long-seq');
  if (typeof fitCharLine === 'function') fitCharLine();

  cont.dataset.toggled = '0';
  cont.onclick = (e) => {
    e.stopPropagation();
    
    // Désactiver en mode pinyin
    if (isPinyinGameMode()) return;
    
    const showPinyin = !!document.getElementById('showPinyin')?.checked;
    const showDefs   = !!document.getElementById('showDefs')?.checked;
    const toggled    = cont.dataset.toggled === '1';

    if (!showPinyin && !showDefs) {
      const bothHidden = (pEl.style.display === 'none' && dEl.style.display === 'none');
      pEl.style.display = bothHidden ? '' : 'none';
      dEl.style.display = bothHidden ? '' : 'none';
      cont.dataset.toggled = bothHidden ? '1' : '0';
      return;
    }

    if (!toggled) {
      if (showPinyin && !showDefs) {
        dEl.style.display = '';
      } else if (!showPinyin && showDefs) {
        pEl.style.display = '';
      } else {
        pEl.style.display = 'none';
        dEl.style.display = 'none';
      }
      cont.dataset.toggled = '1';
    } else {
      pEl.style.display = showPinyin ? '' : 'none';
      dEl.style.display = showDefs   ? '' : 'none';
      cont.dataset.toggled = '0';
    }
  };

  // Gestion barres jeu
  if (gameMode) {
    if (isPinyinGameMode() && typeof pinyinFlow !== 'undefined' && pinyinFlow === 'stopOnSelected') {
      document.getElementById('barDefault').style.display = 'grid';
      document.getElementById('ghostBar').style.display = 'none';
      document.getElementById('gameBars').style.display = 'none';
      document.getElementById('gameBarsNoRead').style.display = 'none';
      return;
    }
    if (gameType === 'reorderNoRead') {
      toggleGameBarsNoRead(true);
    } else {
      toggleGameBars(true);
    }
    const gameBars = document.getElementById(gameType === 'reorderNoRead' ? 'gameBarsNoRead' : 'gameBars');
    if (gameBars) {
      gameBars.querySelectorAll('.game-btn').forEach(btn => {
        btn.style.color = contrast;
        btn.style.borderColor = 'none';
        btn.style.background = contrast === '#ffffff' 
          ? 'rgba(255,255,255,0.18)' 
          : 'rgba(0,0,0,0.18)';
      });
    }
  } else {
    toggleGameBars(false);
    toggleGameBarsNoRead(false);
  }
  
  try { enforceMenuState(); } catch (_) {}
}

function applyControlsTheme(contrastColor){
  const isDarkBg = (contrastColor === '#ffffff');
  const elemColor = isDarkBg ? '#ffffff' : '#000000';
  const borderColor = isDarkBg ? 'rgba(255,255,255,0.3)' : 'rgba(0,0,0,0.3)';

  const barDefault = document.getElementById('barDefault');
  if (barDefault) {
    barDefault.querySelectorAll('.slot, #hamburger').forEach(slot => {
      slot.style.color = elemColor;
      slot.style.borderColor = borderColor;
    });
  }
}


// ========= Navigation par phrase =========
const SENT_END_RE = /[。！？.!?]$/;

function computeSentenceStarts(tokArr){
  const starts = [0];
  for (let i=0;i<tokArr.length;i++){
    if (SENT_END_RE.test(tokArr[i].text)) starts.push(i+1);
  }
  if (starts[starts.length-1] === tokArr.length) starts.pop();
  return starts;
}

function findCurrentSentenceIndex(tokArr, currentIdx) {
  const starts = computeSentenceStarts(tokArr);
  for (let i = 0; i < starts.length; i++) {
    if (i === starts.length - 1) return i;
    if (currentIdx >= starts[i] && currentIdx < starts[i + 1]) return i;
  }
  return 0;
}

function getSentenceText(tokArr, sentenceIdx) {
  const starts = computeSentenceStarts(tokArr);
  if (sentenceIdx >= starts.length) return '';

  const startIdx = starts[sentenceIdx];
  let endIdx = tokArr.length;

  if (sentenceIdx < starts.length - 1) {
    endIdx = starts[sentenceIdx + 1];
  }

  return tokArr.slice(startIdx, endIdx).map(t => t.text).join('');
}

// ========= Couleurs =========
function getContrastingColor(hex){
  hex = hex.replace('#','');
  if(hex.length === 3) hex = hex.split('').map(c=>c+c).join('');
  const r = parseInt(hex.substr(0,2),16);
  const g = parseInt(hex.substr(2,2),16);
  const b = parseInt(hex.substr(4,2),16);
  const luminance = (0.299*r + 0.587*g + 0.114*b) / 255;
  return luminance > 0.6 ? "#000000" : "#ffffff";
}

// ========= Repositionnement =========
function restartFrom(index) {
  // 🚫 Bloquer toute relance en mode Pinyin + selectedOnly
  if (isPinyinGameMode() && pinyinFlow === 'selectedOnly') {
    playing = false;
    clearInterval(timer);
    if (typeof updatePinyinPlayIcon === 'function') updatePinyinPlayIcon();
    return;
  }
  
  const text = normalizeChineseText(document.getElementById('inputText').value);
  tokens = attachDictInfo(segmentText(text, dict.wordSet, dict.maxLen), dict.entries);

  if (gameMode) {
    sentenceStarts = computeSentenceStarts(tokens);
  }

  if (!tokens.length) return;

  idx = Math.max(0, Math.min(index, tokens.length - 1));
  clearInterval(timer);
  showToken(tokens[idx]);
  if (typeof fitCharLine === 'function') fitCharLine();
}


// ========= Boucle =========
function updatePlayGameBtnIcon() {
  const btn = document.getElementById('playGameBtn');
  if (!btn) return;

  if (playing) {
    // Icône Pause II
    btn.innerHTML = `
      <svg class="icon" viewBox="0 0 24 24" fill="currentColor">
        <rect x="7" y="6" width="3" height="12"></rect>
        <rect x="14" y="6" width="3" height="12"></rect>
      </svg>`;
  } else {
    // Icône Lecture ▶
    btn.innerHTML = `
      <svg class="icon" viewBox="0 0 24 24" fill="currentColor">
        <polygon points="8,6 18,12 8,18"></polygon>
      </svg>`;
  }
}
function forcePause(){
  playing = false;
  clearInterval(timer);
  const pb = document.getElementById('pauseIcon');
  if (pb) pb.innerHTML = '<polygon points="8,6 18,12 8,18"></polygon>';
  updatePlayGameBtnIcon(); // ← ajoute ça
  if (typeof updatePinyinPlayIcon === 'function') updatePinyinPlayIcon();
}

function forcePlay(skipFirst = false) {
  // 🚫 Bloquer TOUTE lecture en mode Pinyin + selectedOnly
  if (isPinyinGameMode() && pinyinFlow === 'selectedOnly') {
    playing = false;
    clearInterval(timer);
    if (typeof updatePinyinPlayIcon === 'function') updatePinyinPlayIcon();
    return;
  }

  if (!tokens || !tokens.length) return;
  if (gameMode && gameType === 'reorderNoRead') return;

  // En mode lecture normale : si on est sur un mot surligné, passer au suivant
  if (!gameMode && !skipFirst && idx < tokens.length) {
    const currentClean = stripPunct(tokens[idx].text);
    if (highlightWords.includes(currentClean)) {
      skipFirst = true;
    }
  }

  playing = true;
  const pb = document.getElementById('pauseIcon');
  if (pb)
    pb.innerHTML =
      '<rect x="7" y="6" width="3" height="12" fill="currentColor"></rect>' +
      '<rect x="14" y="6" width="3" height="12" fill="currentColor"></rect>';

  if (!skipFirst) showToken(tokens[idx]);
  startLoop(skipFirst);
  updatePlayGameBtnIcon();
  if (typeof updatePinyinPlayIcon === 'function') updatePinyinPlayIcon();
}

function startLoop(skipFirst = false){
  // 🔇 Bloquer toute boucle d'auto-avance en selectedOnly
  if (isPinyinGameMode() && pinyinFlow === 'selectedOnly') {
    playing = false;
    clearInterval(timer);
    if (typeof updatePinyinPlayIcon === 'function') updatePinyinPlayIcon();
    return;
  }
  
  const speedEl = document.getElementById('speed');
  const speed = +(speedEl?.value || 120);
  const ms = Math.max(50, Math.round(60000 / Math.max(1, speed)));
  clearInterval(timer);

  let first = skipFirst;
  timer = setInterval(() => {
    if (!playing) return;

    if (first) {
      first = false;
      return;
    }

    idx++;
    if (idx < tokens.length) {
      showToken(tokens[idx]);

      // Fin de phrase en mode jeu (sauf pinyin et reorderNoRead)
      if (gameMode && gameType !== 'reorderNoRead' && !isPinyinGameMode() && SENT_END_RE.test(tokens[idx].text)) {
        forcePause();
        const gameModeOverlay = document.getElementById('gameModeOverlay');
        const gamePlayOverlay = document.getElementById('gamePlayOverlay');
        if (gameModeOverlay.style.display !== 'flex' && gamePlayOverlay.style.display !== 'flex') {
          setTimeout(() => { openGameModeOverlay(); }, 500);
        }
        return;
      }

      // Pause sur mot surligné
      const clean = stripPunct(tokens[idx].text);
      if (highlightWords.includes(clean)) {
        if (isPinyinGameMode() && pinyinFlow === 'stopOnSelected') {
          forcePause();
          startPinyinGateForCurrentToken();
          return;
        }
        // En mode lecture normale, mettre en pause
        if (!gameMode) {
          forcePause();
        }
      }
    } else {
      // fin du texte
      forcePause();
      idx = 0;
      updatePlayGameBtnIcon();
    }
  }, ms);
}

function ensurePinyinFastOption() {
  // Insertion dynamique de l’option dans le bloc des sous-options Pinyin (accueil)
  const host = document.getElementById('pinyinSubOptions');
  if (!host) return;

  if (!document.getElementById('pinyinFastReveal')) {
    const wrap = document.createElement('label');
    wrap.className = 'opt';
    wrap.style.display = 'flex';
    wrap.style.alignItems = 'center';
    wrap.style.gap = '10px';
    wrap.innerHTML = `
      <input type="checkbox" id="pinyinFastReveal" />
      <span>Révélation rapide</span>
    `;
    host.appendChild(wrap);
  }
}

function isFastRevealEnabled() {
  return !!document.getElementById('pinyinFastReveal')?.checked;
}


// ========= UI Management =========
function updateUI() {
  const readMode = document.getElementById('readMode').checked;
  const gameMode = document.getElementById('gameMode').checked;
  
  const toggleEdit = document.getElementById('toggleEdit');
  const selectAllWords = document.getElementById('selectAllWords');
  const pinyinOption = document.getElementById('pinyinOption');
  const translationOption = document.getElementById('translationOption');
  const selectionOption = document.getElementById('selectionOption');
  const highlightBgSwatch = document.getElementById('highlightBgSwatch');
  const highlightColorSwatch = document.getElementById('highlightColorSwatch');
  const gameModeOptions = document.getElementById('gameModeOptions');
  
  const gameTypeValue = document.querySelector('input[name="gameType"]:checked')?.value || 'both';
  const isPinyinMode = gameTypeValue.includes('pinyin');
  const isReorderNoRead = gameTypeValue === 'reorderNoRead';
  
  const shouldHidePinyinTranslation = (isPinyinMode && gameTypeValue !== 'pinyinKeyboard') || isReorderNoRead;
  
  const needsHighlightColors = isPinyinMode && 
    document.querySelector('input[name="pinyinFlow"]:checked')?.value === 'stopOnSelected';
  
if (readMode) {
  toggleEdit.style.display = 'flex';
  selectAllWords.style.display = 'none';
  pinyinOption.style.display = 'flex';
  translationOption.style.display = 'flex';
  selectionOption.style.display = 'flex';
  highlightBgSwatch.style.display = 'block';
  highlightColorSwatch.style.display = 'block';
  gameModeOptions.style.display = 'none';
} else if (gameMode) {
  toggleEdit.style.display = isPinyinMode ? 'flex' : 'none';
  selectAllWords.style.display = 'none';
  pinyinOption.style.display = shouldHidePinyinTranslation ? 'none' : 'flex';
  translationOption.style.display = shouldHidePinyinTranslation ? 'none' : 'flex';
  selectionOption.style.display = 'none';
  
  // Toujours masquer les couleurs highlight en mode jeu
  highlightBgSwatch.style.display = 'none';
  highlightColorSwatch.style.display = 'none';
  gameModeOptions.style.display = 'block';
  
  const pinyinSub = document.getElementById('pinyinSubOptions');
if (gameMode && isPinyinMode) {
  pinyinSub.style.display = 'block';
  ensurePinyinFastOption(); 
} else {
  pinyinSub.style.display = 'none';
}
}
}

// ========= Taille =========
function fitCharLine() {
  const container = document.getElementById('charContainer');
  const display   = document.getElementById('charDisplay');
  if (!container || !display) return;

  const isMobile = window.matchMedia('(max-width: 600px)').matches;
  const symbols  = display.querySelectorAll('.han, .punc').length;

  if (isMobile) {
    if (symbols <= 3) {
      display.style.fontSize = '80px';
      return;
    }
    let size = 140, minPx = 28, guard = 30;
    display.style.fontSize = size + 'px';
    while (guard-- > 0 && (display.scrollWidth > container.clientWidth * 0.95 || display.scrollHeight > container.clientHeight * 0.95)) {
      size = Math.max(minPx, Math.floor(size * 0.92));
      display.style.fontSize = size + 'px';
    }
    return;
  }

  let maxPx = Math.min(Math.floor(container.clientWidth * 0.85), 180), minPx = 28, size=maxPx, guard=30;
  display.style.fontSize = size + 'px';
  while (guard-- > 0 && (display.scrollWidth > container.clientWidth * 0.98 || display.scrollHeight > container.clientHeight * 0.98)) {
    size = Math.max(minPx, Math.floor(size * 0.92));
    display.style.fontSize = size + 'px';
  }
}

// ========= Fonctions MODE JEU =========
function normalizeForComparison(text) {
  return stripPunct(text)
    .toLowerCase()
    .trim();
}

function extractWordsFromSentence(sentence) {
  const segmented = segmentText(sentence, dict.wordSet, dict.maxLen);
  const words = [];
  
  segmented.forEach(token => {
    if (token.text.trim()) {
      words.push(token.text);
    }
  });
  
  return words;
}

function shuffleArray(array) {
  const shuffled = [...array];
  for (let i = shuffled.length - 1; i > 0; i--) {
    const j = Math.floor(Math.random() * (i + 1));
    [shuffled[i], shuffled[j]] = [shuffled[j], shuffled[i]];
  }
  return shuffled;
}

function applyGameTheme() {
  const normalBg = (bgColorPicker?.getColor()?.toHEXA().toString()) || '#ffffff';
  const normalText = (textColorPicker?.getColor()?.toHEXA().toString()) || '#000000';
  const highlightBg = (highlightBgColorPicker?.getColor()?.toHEXA().toString()) || '#000000';
  const highlightText = (highlightColorPicker?.getColor()?.toHEXA().toString()) || '#ffffff';
  
  const clean = stripPunct(tokens[idx]?.text || '');
  const isHighlighted = highlightWords.includes(clean);
  
  const pageBg = isHighlighted ? highlightBg : normalBg;
  const pageText = isHighlighted ? highlightText : normalText;
  
  const overlays = ['#gameModeOverlay', '#gamePlayOverlay'];
  overlays.forEach(selector => {
    const overlay = document.querySelector(selector);
    if (overlay) {
      const content = overlay.querySelector('.game-overlay-content');
      if (content) {
        content.style.background = pageBg;
        content.style.color = pageText;
      }
    }
  });
}

function toggleGameBars(showGameBars) {
  const normalBar = document.getElementById('barDefault');
  const ghostBar = document.getElementById('ghostBar');
  const gameBars = document.getElementById('gameBars');
  const gameBarsNoRead = document.getElementById('gameBarsNoRead');
  const hamburger = document.getElementById('hamburger');
  const displayPage = document.getElementById('displayPage');
  
  if (showGameBars) {
    normalBar.style.display = 'none';
    ghostBar.style.display = 'none';
    gameBars.style.display = 'block';
    gameBarsNoRead.style.display = 'none';
    displayPage.classList.add('game-mode-active');
    
    if (hamburger) {
      hamburger.style.display = 'flex';
    }
  } else {
    normalBar.style.display = 'grid';
    ghostBar.style.display = 'none';
    gameBars.style.display = 'none';
    gameBarsNoRead.style.display = 'none';
    displayPage.classList.remove('game-mode-active');
  }
}

function toggleGameBarsNoRead(show) {
  const normalBar = document.getElementById('barDefault');
  const ghostBar = document.getElementById('ghostBar');
  const gameBars = document.getElementById('gameBars');
  const gameBarsNoRead = document.getElementById('gameBarsNoRead');
  const displayPage = document.getElementById('displayPage');
  
  if (show) {
    normalBar.style.display = 'none';
    ghostBar.style.display = 'none';
    gameBars.style.display = 'none';
    gameBarsNoRead.style.display = 'block';
    displayPage.classList.add('game-mode-active');
  } else {
    normalBar.style.display = 'grid';
    ghostBar.style.display = 'none';
    gameBars.style.display = 'none';
    gameBarsNoRead.style.display = 'none';
    displayPage.classList.remove('game-mode-active');
  }
}

function goToPreviousSentence() {
  if (currentSentenceIndex > 0) {
    currentSentenceIndex--;
    const startIdx = sentenceStarts[currentSentenceIndex];
    restartFrom(startIdx);
    originalSentence = getSentenceText(tokens, currentSentenceIndex);
    updateGameNavigation();
    updateGameBarNavigation();

    setTimeout(() => { forcePlay(); }, 300);
  } else {
    // déjà à la première phrase → revenir au début de celle-ci
    const startIdx = sentenceStarts[0];
    restartFrom(startIdx);
    forcePause(); // en pause au début
  }
}

function goToNextSentence() {
  if (currentSentenceIndex < sentenceStarts.length - 1) {
    currentSentenceIndex++;
    const startIdx = sentenceStarts[currentSentenceIndex];
    restartFrom(startIdx);
    originalSentence = getSentenceText(tokens, currentSentenceIndex);
    updateGameNavigation();
    updateGameBarNavigation();
    
    if (gameType === 'reorderNoRead') {
      openGamePlayOverlayDirect();
    } else {
      // Relancer la lecture automatiquement pour les autres modes
      setTimeout(() => {
        forcePlay();
      }, 300);
    }
  }
}

function goToRandomSentence() {
  if (sentenceStarts.length <= 1) return;
  
  // Si toutes les phrases ont été jouées, réinitialiser
  if (playedSentences.length >= sentenceStarts.length) {
    playedSentences = [];
  }
  
  // Trouver les phrases non encore jouées
  const availableSentences = [];
  for (let i = 0; i < sentenceStarts.length; i++) {
    if (!playedSentences.includes(i)) {
      availableSentences.push(i);
    }
  }
  
  // S'il ne reste qu'une phrase non jouée, la prendre
  if (availableSentences.length === 1) {
    currentSentenceIndex = availableSentences[0];
  } else {
    // Sinon, choisir aléatoirement parmi les phrases non jouées
    const randomIdx = Math.floor(Math.random() * availableSentences.length);
    currentSentenceIndex = availableSentences[randomIdx];
  }
  
  // Marquer cette phrase comme jouée
  if (!playedSentences.includes(currentSentenceIndex)) {
    playedSentences.push(currentSentenceIndex);
  }
  
  const startIdx = sentenceStarts[currentSentenceIndex];
  idx = startIdx;
  originalSentence = getSentenceText(tokens, currentSentenceIndex);
  updateGameNavigation();
  
  // En mode reorderNoRead, juste recharger le contenu de l'overlay
  if (gameType === 'reorderNoRead') {
    // S'assurer que l'overlay est visible
    const overlay = document.getElementById('gamePlayOverlay');
    if (overlay.style.display !== 'flex') {
      overlay.style.display = 'flex';
    }
    // Recharger le jeu
    initReorderGame();
  } else {
    initReorderGame();
  }
}

function replaySentence() {
  const startIdx = sentenceStarts[currentSentenceIndex];
  restartFrom(startIdx);
  forcePause();
  closeGameModeOverlay();
  closeGamePlayOverlay();
  setTimeout(() => {
    forcePlay();
  }, 300);
}

function updateGameBarNavigation() {
  const prevBtn = document.getElementById('prevSentenceBtn');
  const nextBtn = document.getElementById('nextSentenceBtn');
  const playBtn = document.getElementById('playGameBtn');
  const prevBtnNoRead = document.getElementById('prevSentenceNoReadBtn');
  const nextBtnNoRead = document.getElementById('nextSentenceNoReadBtn');
  
  if (prevBtn) prevBtn.disabled = currentSentenceIndex === 0;
  if (nextBtn) nextBtn.disabled = currentSentenceIndex >= sentenceStarts.length - 1;
  if (prevBtnNoRead) prevBtnNoRead.disabled = currentSentenceIndex === 0;
  if (nextBtnNoRead) nextBtnNoRead.disabled = currentSentenceIndex >= sentenceStarts.length - 1;
  
  if (playBtn) playBtn.disabled = false;
}

function openGameManually() {
  // Arrêter la lecture
  forcePause();
  
  // Vérifier si une fenêtre de jeu est déjà ouverte
  const gameModeOverlay = document.getElementById('gameModeOverlay');
  const gamePlayOverlay = document.getElementById('gamePlayOverlay');
  
  if (gameModeOverlay.style.display === 'flex' || gamePlayOverlay.style.display === 'flex') {
    return; // Ne rien faire si une fenêtre est déjà ouverte
  }
  
  currentSentenceIndex = findCurrentSentenceIndex(tokens, idx);
  originalSentence = getSentenceText(tokens, currentSentenceIndex);
  
  if (gameType === 'both') {
    openGameModeOverlay();
  } else if (gameType === 'reorder' || gameType === 'reorderNoRead') {
    openGamePlayOverlay('reorder');
  } else if (gameType === 'free') {
    openGamePlayOverlay('free');
  }
}

function openGameModeOverlay() {
  currentSentenceIndex = findCurrentSentenceIndex(tokens, idx);
  originalSentence = getSentenceText(tokens, currentSentenceIndex);
  
  const overlay = document.getElementById('gameModeOverlay');
  showBackdrop(); // ← AJOUT
  overlay.style.display = 'flex';
  applyGameTheme();
  
  const prevBtn = document.getElementById('prevSentenceGame');
  const nextBtn = document.getElementById('nextSentenceGame');
  
  prevBtn.disabled = currentSentenceIndex === 0;
  nextBtn.disabled = currentSentenceIndex >= sentenceStarts.length - 1;
}

function closeGameModeOverlay() {
  document.getElementById('gameModeOverlay').style.display = 'none';
  hideBackdrop(); // ← AJOUT
}

function openGamePlayOverlay(mode) {
  currentGameMode = mode;
  closeGameModeOverlay();
  
  const overlay = document.getElementById('gamePlayOverlay');
  showBackdrop(); // ← AJOUT
  overlay.style.display = 'flex';
  applyGameTheme();
  
  const reorderBtn = document.getElementById('switchReorder');
  const freeBtn = document.getElementById('switchFree');
  const switcher = document.querySelector('.mode-switcher');
  
  // Gérer la visibilité de la croix de fermeture
const closeBtn = document.getElementById('closeGamePlay');
if (closeBtn) {
  if (gameType === 'reorderNoRead') {
    closeBtn.style.display = 'none';
  } else {
    closeBtn.style.display = 'block';
  }
}
  
  // Hide switcher based on game type
  if (gameType === 'reorder' || gameType === 'reorderNoRead') {
    switcher.style.display = 'none';
    mode = 'reorder';
  } else if (gameType === 'free') {
    switcher.style.display = 'none';
    mode = 'free';
  } else {
    switcher.style.display = 'flex';
  }
  
  if (mode === 'reorder') {
    reorderBtn.classList.add('active');
    freeBtn.classList.remove('active');
    document.getElementById('reorderGame').style.display = 'block';
    document.getElementById('freeGame').style.display = 'none';
    initReorderGame();
  } else {
    freeBtn.classList.add('active');
    reorderBtn.classList.remove('active');
    document.getElementById('freeGame').style.display = 'block';
    document.getElementById('reorderGame').style.display = 'none';
    initFreeGame();
  }
  
  // Gérer les boutons selon le mode
const replayBtn = document.getElementById('replayInGame');
const prevBtn = document.getElementById('prevSentenceInGame');
const nextBtn = document.getElementById('nextSentenceInGame');

if (gameType === 'reorderNoRead') {
  // MODE RÉORGANISER SANS LECTURE - Comportement spécial
  if (replayBtn) replayBtn.style.display = 'none';
  
  if (prevBtn) {
    prevBtn.textContent = '✕ Quitter';
    prevBtn.disabled = false;
    prevBtn.onclick = () => {
      closeGamePlayOverlay();
      document.body.style.backgroundColor = '';
      idx = 0;
      document.getElementById('homePage').style.display = 'block';
    };
  }
  
  if (nextBtn) {
    nextBtn.textContent = 'Suivante →';
    nextBtn.disabled = false;
    nextBtn.onclick = () => {
      // Action aléatoire derrière le bouton "Suivante"
      goToRandomSentence();
    };
  }
} else {
  // AUTRES MODES - Comportement normal
  if (replayBtn) replayBtn.style.display = 'block';
  
  if (prevBtn) {
    prevBtn.textContent = '← Précédente';
    prevBtn.onclick = () => {
      goToPreviousSentence();
      closeGamePlayOverlay();
    };
  }
  
  if (nextBtn) {
    nextBtn.textContent = 'Suivante →';
    nextBtn.onclick = () => {
      goToNextSentence();
      closeGamePlayOverlay();
    };
  }
}

updateGameNavigation();
}

function openGamePlayOverlayDirect() {
  currentSentenceIndex = findCurrentSentenceIndex(tokens, idx);
  originalSentence = getSentenceText(tokens, currentSentenceIndex);
  openGamePlayOverlay('reorder');
}

function closeGamePlayOverlay() {
  document.getElementById('gamePlayOverlay').style.display = 'none';
  hideBackdrop();
}

function updateGameNavigation() {
  const prevBtn = document.getElementById('prevSentenceInGame');
  const nextBtn = document.getElementById('nextSentenceInGame');
  
  // En mode reorderNoRead, les boutons ont un comportement spécial et ne doivent jamais être désactivés
  if (gameType === 'reorderNoRead') {
    if (prevBtn) {
      prevBtn.disabled = false;
      prevBtn.style.opacity = '1';
      prevBtn.style.cursor = 'pointer';
    }
    if (nextBtn) {
      nextBtn.disabled = false;
      nextBtn.style.opacity = '1';
      nextBtn.style.cursor = 'pointer';
    }
  } else {
    // Mode normal
    if (prevBtn) prevBtn.disabled = currentSentenceIndex === 0;
    if (nextBtn) nextBtn.disabled = currentSentenceIndex >= sentenceStarts.length - 1;
  }
}

function initReorderGame() {
  const words = extractWordsFromSentence(originalSentence);
  const shuffledWords = shuffleArray(words);
  
  const availableWordsContainer = document.getElementById('availableWords');
  const userSentenceContainer = document.getElementById('userSentence');
  
  availableWordsContainer.innerHTML = '';
  userSentenceContainer.innerHTML = '';
  
  shuffledWords.forEach(word => {
    const token = createWordToken(word);
    availableWordsContainer.appendChild(token);
  });
  
  document.getElementById('reorderResult').style.display = 'none';
  document.getElementById('retryReorder').style.display = 'none';
  document.getElementById('validateReorder').style.display = 'block';
  
  setupDragAndDrop();
}

function createWordToken(text) {
  const token = document.createElement('div');
  token.className = 'word-token';
  token.textContent = text;
  token.draggable = true;
  
  token.addEventListener('click', (e) => {
    e.preventDefault();
    const availableContainer = document.getElementById('availableWords');
    const userContainer = document.getElementById('userSentence');
    
    if (token.parentNode === availableContainer) {
      userContainer.appendChild(token);
    } else {
      availableContainer.appendChild(token);
    }
  });
  
  return token;
}


function setupDragAndDrop() {
  const containers = ['availableWords', 'userSentence'];
  
  containers.forEach(containerId => {
    const container = document.getElementById(containerId);
    
    container.addEventListener('dragover', (e) => {
  e.preventDefault();
  const dragging = document.querySelector('.dragging');
  if (!dragging) return;
  
  const afterElement = getDragAfterElement(container, e.clientX, e.clientY);
  if (afterElement == null) {
    container.appendChild(dragging);
  } else {
    container.insertBefore(dragging, afterElement);
  }
});
    
    container.addEventListener('drop', (e) => {
      e.preventDefault();
    });
  });
  
  document.addEventListener('dragstart', (e) => {
    if (e.target.classList.contains('word-token')) {
      e.target.classList.add('dragging');
      e.dataTransfer.effectAllowed = 'move';
    }
  });
  
  document.addEventListener('dragend', (e) => {
    if (e.target.classList.contains('word-token')) {
      e.target.classList.remove('dragging');
    }
  });
}

function getDragAfterElement(container, x, y) {
  const els = [...container.querySelectorAll('.word-token:not(.dragging)')];
  if (!els.length) return null;

  // Construire les lignes (tolérance Y)
  const TOL = 8;
  const lines = [];
  for (const node of els) {
    const rects = Array.from(node.getClientRects());
    for (const r of rects) {
      let line = lines.find(L => Math.abs(L.top - r.top) <= TOL);
      if (!line) {
        line = { top: r.top, bottom: r.bottom, items: [] };
        lines.push(line);
      } else {
        line.top = Math.min(line.top, r.top);
        line.bottom = Math.max(line.bottom, r.bottom);
      }
      line.items.push({ node, rect: r });
    }
  }
  lines.sort((a, b) => a.top - b.top);
  lines.forEach(L => L.items.sort((a, b) => a.rect.left - b.rect.left));

  // Choisir la ligne la plus proche en Y
  let bestLine = null, bestDy = Infinity;
  for (const L of lines) {
    const cy = (L.top + L.bottom) / 2;
    const dy = Math.abs(y - cy);
    if (dy < bestDy) { bestDy = dy; bestLine = L; }
  }

  if (!bestLine || !bestLine.items.length) return null;

  // Début de ligne : renvoyer le 1er élément (insertion avant lui)
  const first = bestLine.items[0];
  if (x < first.rect.left) return first.node;

  // Fin de ligne : renvoyer null pour indiquer "append at end of this line"
  const last = bestLine.items[bestLine.items.length - 1];
  if (x > last.rect.right) return last.node.nextSibling || null;

  // Entre deux : trouver l’élément après lequel insérer
  let chosen = null, bestDx = Infinity;
  for (const it of bestLine.items) {
    const midX = (it.rect.left + it.rect.right) / 2;
    const dx = x - midX;
    const adx = Math.abs(dx);
    if (adx < bestDx) { bestDx = adx; chosen = { it, dx }; }
  }
  // si x est à gauche du centre → on insère avant l’élément; sinon après
  if (chosen.dx < 0) return chosen.it.node;               // insertBefore(chosen.it.node)
  return chosen.it.node.nextSibling || null;              // insertAfter
}


function initFreeGame() {
  const textarea = document.getElementById('freeTextInput');
  textarea.value = '';
  textarea.focus();
  
  document.getElementById('freeResult').style.display = 'none';
  document.getElementById('retryFree').style.display = 'none';
  document.getElementById('validateFree').style.display = 'block';
}

function validateReorderGame() {
  const userSentenceContainer = document.getElementById('userSentence');
  const userWords = Array.from(userSentenceContainer.children).map(token => token.textContent);
  const userSentence = userWords.join('');
  
  const isCorrect = normalizeForComparison(userSentence) === normalizeForComparison(originalSentence);
  
  const resultDiv = document.getElementById('reorderResult');
  resultDiv.style.display = 'block';
  resultDiv.className = 'result-message ' + (isCorrect ? 'success' : 'error');
  
  if (isCorrect) {
    resultDiv.textContent = '✅ Bravo ! La phrase est correcte : ' + originalSentence;
  } else {
    resultDiv.textContent = '❌ Incorrect. Réessayez !';
  }
  
  document.getElementById('validateReorder').style.display = 'none';
  document.getElementById('retryReorder').style.display = 'block';
}

function validateFreeGame() {
  const textarea = document.getElementById('freeTextInput');
  const userText = textarea.value.trim();
  
  const isCorrect = normalizeForComparison(userText) === normalizeForComparison(originalSentence);
  
  const resultDiv = document.getElementById('freeResult');
  resultDiv.style.display = 'block';
  resultDiv.className = 'result-message ' + (isCorrect ? 'success' : 'error');
  
  if (isCorrect) {
    resultDiv.textContent = '✅ Bravo ! La phrase est correcte : ' + originalSentence;
  } else {
    resultDiv.textContent = '❌ Incorrect. Réessayez !';
  }
  
  document.getElementById('validateFree').style.display = 'none';
  document.getElementById('retryFree').style.display = 'block';
}

function switchGameMode(newMode) {
  currentGameMode = newMode;
  
  const reorderBtn = document.getElementById('switchReorder');
  const freeBtn = document.getElementById('switchFree');
  const reorderGame = document.getElementById('reorderGame');
  const freeGame = document.getElementById('freeGame');
  
  if (newMode === 'reorder') {
    reorderBtn.classList.add('active');
    freeBtn.classList.remove('active');
    reorderGame.style.display = 'block';
    freeGame.style.display = 'none';
    initReorderGame();
  } else {
    freeBtn.classList.add('active');
    reorderBtn.classList.remove('active');
    freeGame.style.display = 'block';
    reorderGame.style.display = 'none';
    initFreeGame();
  }
}

// ========= Overlays =========
function openSelectionOverlay() {
  const text = normalizeChineseText(document.getElementById('inputText').value);
  const segmented = attachDictInfo(segmentText(text, dict.wordSet, dict.maxLen), dict.entries);
  const container = document.getElementById('segmentedOverlayText');
  container.innerHTML = '';

  segmented.forEach((tok) => {
    const el = document.createElement('span');
    el.textContent = tok.text;
    const clean = stripPunct(tok.text);
    if (highlightWords.includes(clean)) el.classList.add('selected');
    
    el.addEventListener('click', () => {
      if (highlightWords.includes(clean)) {
        highlightWords = highlightWords.filter(w => w !== clean);
      } else {
        highlightWords.push(clean);
      }
      openSelectionOverlay();
    });
    
    container.appendChild(el);
  });

  showBackdrop();
  document.getElementById('selectionOverlay').style.display = 'flex';
}


function closeSelectionOverlay() {
  document.getElementById('selectionOverlay').style.display = 'none';
  hideBackdrop(); // ← AJOUT
}

// Modifier openInfoOverlay (vers ligne 1028)
function openInfoOverlay() {
  const overlay = document.getElementById('infoOverlay');
  const body = document.getElementById('infoWords');
  if (!overlay || !body) return;
  
  infoWasPlaying = !!playing;
  forcePause();
  
  body.innerHTML = '';
  
  const normalBg = (bgColorPicker?.getColor()?.toHEXA().toString()) || '#ffffff';
  const normalText = (textColorPicker?.getColor()?.toHEXA().toString()) || '#000000';
  const highlightBg = (highlightBgColorPicker?.getColor()?.toHEXA().toString()) || '#ef4444';
  const highlightText = (highlightColorPicker?.getColor()?.toHEXA().toString()) || '#ffffff';
  
  const cleanCurrent = stripPunct(tokens[idx]?.text || '');
  const isH = highlightWords.includes(cleanCurrent);
  
  const pageBg = isH ? highlightBg : normalBg;
  const pageFg = isH ? highlightText : normalText;
  
  overlay.style.setProperty('--info-bg', pageBg);
  overlay.style.setProperty('--info-fg', pageFg);
  
  tokens.forEach((tok, i) => {
    const span = document.createElement('span');
    span.textContent = tok.text;
    span.className = 'info-word';
    
    const clean = stripPunct(tok.text);
    if (highlightWords.includes(clean)) span.classList.add('initialSelected');
    if (i === idx) span.classList.add('current');
    
    span.onclick = () => {
      infoChosenIndex = i;
      body.querySelectorAll('.info-word.chosen').forEach(el => el.classList.remove('chosen'));
      span.classList.add('chosen');
    };
    
    body.appendChild(span);
  });
  
  showBackdrop(); // ← AJOUT
  overlay.style.display = 'flex';
}

function closeInfoOverlay() {
  document.getElementById('infoOverlay').style.display = 'none';
  hideBackdrop(); 
}

function wireInfoOverlayControls() {
  const infoBtn = document.getElementById('infoBtn');
  const infoValidateBtn = document.getElementById('infoValidateBtn');
  const infoCancelBtn = document.getElementById('infoCancelBtn');
  const infoCloseBtn = document.getElementById('infoCloseBtn');
  
  if (!infoBtn || !infoValidateBtn || !infoCancelBtn || !infoCloseBtn) return;
  
  infoBtn.onclick = () => { openInfoOverlay(); };
  
  infoValidateBtn.onclick = () => {
    if (infoChosenIndex != null) {
      restartFrom(infoChosenIndex);
      forcePause();
    }
    closeInfoOverlay();
  };
  
  const cancel = () => {
    closeInfoOverlay();
    if (infoWasPlaying) forcePlay();
    infoWasPlaying = false;
    infoChosenIndex = null;
  };
  
  infoCancelBtn.onclick = cancel;
  infoCloseBtn.onclick = cancel;
}

function enableMobileDnD() {
  const isMobile = matchMedia('(pointer:coarse)').matches && matchMedia('(hover: none)').matches;
  if (!isMobile) return;

  const pool = document.getElementById('availableWords');
  const sentence = document.getElementById('userSentence');
  if (!pool || !sentence) return; // sécurité
  
   const FINGER_OFFSET_X = 0; // décalage horizontal du fantôme par rapport au doigt
  const FINGER_OFFSET_Y = -30; // décalage vertical du fantôme

  let pressTimer = null, dragging = false;
  let srcEl = null, ghost = null, placeholder = null, caret = null, activeContainer = null;

  // Long press pour entrer en mode drag
  const LONG_PRESS_MS = 180;

  // Attach sur les conteneurs (délégation)
  [pool, sentence].forEach(zone => {
    zone.addEventListener('pointerdown', onPointerDown, { passive: true });
  });

  // Empêche le scroll pendant le drag
  window.addEventListener('pointermove', onPointerMove, { passive: false });
  window.addEventListener('pointerup', onPointerUp, { passive: true });
  window.addEventListener('pointercancel', onPointerUp, { passive: true });

  function onPointerDown(e) {
    const token = e.target.closest('.word-token');
    if (!token) return;
    if (pressTimer) clearTimeout(pressTimer);

    srcEl = token;
    pressTimer = setTimeout(() => {
      startDrag(e);
    }, LONG_PRESS_MS);
  }

  function startDrag(e) {
    dragging = true;
    // fantôme
    ghost = srcEl.cloneNode(true);
    ghost.classList.add('drag-ghost');
    document.body.appendChild(ghost);

    // placeholder (même largeur approx. pour garder la mise en ligne)
    placeholder = document.createElement('span');
    placeholder.className = 'placeholder-token';
    placeholder.style.width = Math.ceil(srcEl.getBoundingClientRect().width) + 'px';

    // caret (barre d’insertion)
    caret = document.createElement('div');
    caret.className = 'drop-caret';
    caret.style.display = 'none';
    document.body.appendChild(caret);

// dimensions de la source
const r = srcEl.getBoundingClientRect();

// fantôme déjà cloné -> rien à faire ici, il prend la taille du token

// placeholder : même largeur ET hauteur que le token
placeholder = document.createElement('span');
placeholder.className = 'placeholder-token';
placeholder.style.width  = Math.ceil(r.width)  + 'px';
placeholder.style.height = Math.ceil(r.height) + 'px';
placeholder.style.lineHeight = Math.ceil(r.height) + 'px'; // cohérence verticale

// caret : même hauteur que le token
caret = document.createElement('div');
caret.className = 'drop-caret';
caret.style.height = Math.ceil(r.height) + 'px';
caret.style.display = 'none';
document.body.appendChild(caret);

    // source invisible pendant le drag
    srcEl.classList.add('drag-source');

    // définir container actif (au départ, celui d’origine)
    activeContainer = srcEl.parentElement;

    // insérer placeholder à la position d’origine (avant la source)
    activeContainer.insertBefore(placeholder, srcEl);

    // activer style “on”
    [pool, sentence].forEach(z => z.classList.add('drop-zone--active'));

    moveGhost(e);
    e.preventDefault();
  }

  function onPointerMove(e) {
    if (!dragging) return;
    moveGhost(e);

    // déterminer conteneur sous le doigt
    const targetContainer = getContainerUnder(e.clientX, e.clientY) || activeContainer;
    if (targetContainer !== activeContainer) {
      activeContainer = targetContainer;
    }

    // calculer index d’insertion dans le conteneur actif
    positionPlaceholder(activeContainer, e.clientX, e.clientY);
  }

  function onPointerUp(e) {
    if (pressTimer) {
      clearTimeout(pressTimer);
      pressTimer = null;
    }
    if (!dragging) { srcEl = null; return; }

    // Drop : remplacer placeholder par la source
    try {
      activeContainer.insertBefore(srcEl, placeholder);
    } catch(_) {}

    cleanupDrag();

    // (optionnel) déclenche ton recalcul de “bonne phrase” si tu en as un
    // ex: updateUserSentenceOrder();  // à toi de brancher si nécessaire
  }

function moveGhost(e) {
  if (!ghost) return;

  // décalage pour que le mot ne soit pas sous le doigt
  const FINGER_OFFSET_X = 0;    // centré horizontalement
  const FINGER_OFFSET_Y = -30;  // remonte le mot au-dessus du doigt

  ghost.style.left = (e.clientX + FINGER_OFFSET_X) + 'px';
  ghost.style.top  = (e.clientY + FINGER_OFFSET_Y) + 'px';
}


  function getContainerUnder(x, y) {
    // neutraliser temporairement ghost pour connaître l’élément sous le doigt
    ghost.style.display = 'none';
    const el = document.elementFromPoint(x, y);
    ghost.style.display = '';
    const zone = el?.closest?.('.words-container');
    return (zone === pool || zone === sentence) ? zone : null;
  }

  function positionPlaceholder(container, x, y) {
  // Cas conteneur vide
  if (!container.children.length) {
    container.appendChild(placeholder);
    caret.style.left = x + 'px';
    caret.style.top  = y + 'px';
    caret.style.display = 'block';
    return;
  }

  const children = Array.from(container.children).filter(ch => ch !== placeholder);

  // ---- 1) Construire les lignes (groupement par top avec tolérance) ----
  const TOL = 8; // px de tolérance vertical pour regrouper dans une ligne
  const lines = []; // [{ top, bottom, items: [{node, rect}] }]
  for (const node of children) {
    // Un token peut avoir plusieurs rects, on les prend tous
    const rects = Array.from(node.getClientRects());
    for (const r of rects) {
      // essayer d'attacher ce rect à une ligne existante (proche en Y)
      let line = lines.find(L => Math.abs(L.top - r.top) <= TOL);
      if (!line) {
        line = { top: r.top, bottom: r.bottom, items: [] };
        lines.push(line);
      } else {
        line.top = Math.min(line.top, r.top);
        line.bottom = Math.max(line.bottom, r.bottom);
      }
      line.items.push({ node, rect: r });
    }
  }
  // trier les lignes par Y
  lines.sort((a, b) => a.top - b.top);
  // dans chaque ligne, trier les items par X
  lines.forEach(L => L.items.sort((a, b) => a.rect.left - b.rect.left));

  // ---- 2) Trouver la ligne la plus proche du pointeur (en Y) ----
  let bestLine = null, bestDy = Infinity;
  for (const L of lines) {
    // distance verticale du centre de la ligne
    const cy = (L.top + L.bottom) / 2;
    const dy = Math.abs(y - cy);
    if (dy < bestDy) { bestDy = dy; bestLine = L; }
  }
  if (!bestLine || !bestLine.items.length) {
    // fallback
    container.appendChild(placeholder);
    caret.style.left = x + 'px';
    caret.style.top  = y + 'px';
    caret.style.display = 'block';
    return;
  }

  // ---- 3) Décider la position dans CETTE ligne uniquement ----
  const first = bestLine.items[0];
  const last  = bestLine.items[bestLine.items.length - 1];

  // a) avant le tout premier de la ligne
  if (y >= bestLine.top - TOL && y <= bestLine.bottom + TOL && x < first.rect.left) {
    container.insertBefore(placeholder, first.node);
    caret.style.left = first.rect.left + 'px';
    caret.style.top  = (bestLine.top + (bestLine.bottom - bestLine.top - 28)/2) + 'px';
    caret.style.display = 'block';
    return;
  }

  // b) après le tout dernier de la ligne
  if (y >= bestLine.top - TOL && y <= bestLine.bottom + TOL && x > last.rect.right) {
    container.insertBefore(placeholder, last.node.nextSibling);
    caret.style.left = last.rect.right + 'px';
    caret.style.top  = (bestLine.top + (bestLine.bottom - bestLine.top - 28)/2) + 'px';
    caret.style.display = 'block';
    return;
  }

  // c) entre deux éléments de la ligne
  // trouver l’item dont le centre X est le plus proche
  let target = null, bestDx = Infinity;
  for (const it of bestLine.items) {
    const midX = (it.rect.left + it.rect.right) / 2;
    const dx = Math.abs(x - midX);
    if (dx < bestDx) { bestDx = dx; target = it; }
  }

  if (target) {
    const midX = (target.rect.left + target.rect.right) / 2;
    const before = x < midX;
    container.insertBefore(placeholder, before ? target.node : target.node.nextSibling);

    // Caret (feedback visuel) exactement sous le pointeur
    caret.style.left = x + 'px';
    // aligner la hauteur du caret sur la ligne courante
const lineHeight = bestLine.bottom - bestLine.top;
caret.style.top = (bestLine.top + (lineHeight - parseInt(caret.style.height || '28')) / 2) + 'px';
    caret.style.display = 'block';
  }
}


  function placeCaretNearRect(rect, at='end') {
    if (!caret) return;
    const x = (at === 'start') ? rect.left : rect.right;
    const y = rect.top + (rect.height - 28) / 2;
    caret.style.left = x + 'px';
    caret.style.top  = y + 'px';
    caret.style.display = 'block';
  }

  function cleanupDrag() {
    dragging = false;
    if (ghost?.parentNode) ghost.parentNode.removeChild(ghost);
    if (caret?.parentNode) caret.parentNode.removeChild(caret);
    if (placeholder?.parentNode) placeholder.parentNode.removeChild(placeholder);
    [pool, sentence].forEach(z => z.classList.remove('drop-zone--active'));
    if (srcEl) srcEl.classList.remove('drag-source');

    ghost = caret = placeholder = srcEl = null;
    activeContainer = null;
  }

  // Annule le drag si l’utilisateur “tapote” (pas d’appui long)
  window.addEventListener('pointerdown', () => {}, { passive: true });
  window.addEventListener('pointerup', () => {
    if (pressTimer) { clearTimeout(pressTimer); pressTimer = null; }
  }, { passive: true });

  // HACK : sur mobile, on masque tes flèches de déplacement si elles existent
  try {
    document.querySelectorAll('.word-controls').forEach(el => el.style.display = 'none');
  } catch(_) {}
}

// Active à la fin du chargement
  enableMobileDnD();



// ========= Menu =========
function showMenu() {
  __menuHiddenByUser = false;
  
  if (gameMode) {
    if (isPinyinGameMode() && typeof pinyinFlow !== 'undefined' && pinyinFlow === 'stopOnSelected') {
      document.getElementById('barDefault').style.display = 'grid';
      document.getElementById('ghostBar').style.display = 'none';
      document.getElementById('gameBars').style.display = 'none';
      document.getElementById('gameBarsNoRead').style.display = 'none';
      return;
    }
    if (gameType === 'reorderNoRead') {
      document.getElementById('gameBarsNoRead').style.display = 'block';
    } else {
      document.getElementById('gameBars').style.display = 'block';
    }
  } else {
    document.querySelectorAll('#barDefault .slot:not(#hamburger)').forEach(s => {
      s.style.display = 'flex';
    });
    const ghost = document.getElementById('ghostBar');
    if (ghost) {
      ghost.style.display = 'none';
      ghost.setAttribute('aria-hidden', 'true');
      ghost.setAttribute('inert', '');
    }
  }
}

function hideMenu() {
  __menuHiddenByUser = true;
  
  if (gameMode) {
    document.getElementById('gameBars').style.display = 'none';
    document.getElementById('gameBarsNoRead').style.display = 'none';
  } else {
    document.querySelectorAll('#barDefault .slot:not(#hamburger)').forEach(s => {
      s.style.display = 'none';
    });
    const ghost = document.getElementById('ghostBar');
    if (ghost) {
      ghost.style.display = 'grid';
      ghost.removeAttribute('inert');
      ghost.setAttribute('aria-hidden', 'false');
    }
  }
}

function enforceMenuState() {
  if (__menuHiddenByUser) hideMenu();
  else showMenu();
}


// ========= Mode Pinyin =========

function isPinyinGameMode() {
  return gameMode && gameType && gameType.includes('pinyin');
}

function startPinyinGateForCurrentToken() {
  if (!isPinyinGameMode() || pinyinFlow !== 'stopOnSelected') return;
  
  const currentToken = tokens[idx];
  if (!currentToken) return;
  
const clean = stripPunct(currentToken.text);
const pinyinIndex = pinyinSelectedWords.findIndex(tok => stripPunct(tok.text) === clean)
  
  if (pinyinIndex === -1) return;
  
  pinyinGateActive = true;
  currentPinyinWordIndex = pinyinIndex;
  
  const wordLength = clean.length;
  pinyinInput = new Array(wordLength).fill('');
  currentCharacterIndex = 0;
  pinyinValidated = false;
  
  createPinyinInputBoxes(clean);
  
  if (pinyinMode === 'keyboard') {
    showPinyinKeyboard();
  } else {
    showToneSelection(clean);
  }
}

function resumeAfterPinyinGate() {
  pinyinGateActive = false;
  if (isReadBlocked()) {        // 🔇 aucune reprise en selectedOnly
    playing = false;
    clearInterval(timer);
    updatePinyinPlayIcon?.();
    return;
  }
  setTimeout(() => { forcePlay(); }, 100);
}

// Supprime toute ponctuation (chinoise + occidentale). Fallback si \p{} indisponible.
function stripPunct(s) {
  try {
    // Ponctuation \p{P} + symboles \p{S} (pour capturer les variantes pleine-chasse)
    return s.replace(/[\p{P}\p{S}]/gu, '');
  } catch (_) {
    // Fallback large sans \p{} (inclut 。 ， 、 ！ ？ 《》 “” ‘’ （） 等)
    return s.replace(/[。．，、；：？！…—～《》〈〉「」『』〔〕【】（）﹁﹂﹃﹄“”‘’·、,.!?;:'"()\-\u2013\u2014\[\]{}<>]/g, '');
  }
}


function initPinyinGame() {
  // Filtrer les tokens pour ne garder que les mots sélectionnés (Han uniquement)
  pinyinSelectedWords = tokens.filter(tok => {
    const clean = stripPunct(tok.text);
    return tok.type === 'han' && highlightWords.includes(clean);
  });
  
  if (pinyinSelectedWords.length === 0) {
    alert("Aucun mot sélectionné pour le test pinyin !");
    return false;
  }
  
  currentPinyinWordIndex = 0;
  currentCharacterIndex = 0;
  pinyinInput = [];
  pinyinValidated = false;
  pinyinGateActive = false; // ✅ Ajouter cette ligne
  
  // Déterminer le sous-mode
  if (gameType === 'pinyinKeyboard') pinyinMode = 'keyboard';
  else if (gameType === 'pinyinToneLetters') pinyinMode = 'toneWithLetters';
  else if (gameType === 'pinyinTone') pinyinMode = 'toneOnly';
  
  showPinyinWord();
  return true;
}

function showPinyinWord() {
  // Ne clear les timers QUE si on n'est pas en train d'avancer automatiquement
  // (les timers seront déjà cleared dans displayPinyinSequence)
  
  // Nettoyer immédiatement pinyin et traduction
  const pEl = document.getElementById('pinyin');
  const dEl = document.getElementById('defs');
  if (pEl) {
    pEl.style.display = 'none';
    pEl.textContent = '';
  }
  if (dEl) {
    dEl.style.display = 'none';
    dEl.textContent = '';
  }

  // Réinitialiser le clavier physique
  removePhysicalKeyboard();
  
  if (currentPinyinWordIndex >= pinyinSelectedWords.length) {
    quitPinyinGame();
    return;
  }
  
  const word = pinyinSelectedWords[currentPinyinWordIndex];
  const clean = stripPunct(word.text);
  
  // Réinitialiser l'input
  pinyinInput = new Array(clean.length).fill('');
  currentCharacterIndex = 0;
  pinyinValidated = false;
  
  // Afficher le mot
  showToken(word);
  
  // ✅ S'assurer que tout est visible
  const charDisplay = document.getElementById('charDisplay');
  if (charDisplay) {
    charDisplay.style.opacity = '1';
    charDisplay.style.visibility = 'visible';
  }
  
  // Créer les boîtes d'input
  createPinyinInputBoxes(clean);
  
  // Afficher l'interface appropriée
  if (pinyinMode === 'keyboard') {
    const keyboard = document.getElementById('pinyinKeyboard');
    if (keyboard) {
      keyboard.style.display = 'block';
      keyboard.style.opacity = '1';
    }
    showPinyinKeyboard();
  } else {
    const toneSelection = document.getElementById('toneSelection');
    if (toneSelection) {
      toneSelection.style.display = 'block';
      toneSelection.style.opacity = '1';
    }
    showToneSelection(clean);
  }
  
  // Réactiver le clavier physique si mode keyboard
  if (pinyinMode === 'keyboard') {
    setupPhysicalKeyboard();
  }
}

function createPinyinInputBoxes(text) {
  let container = document.getElementById('pinyinInputBoxes');
  if (!container) {
    container = document.createElement('div');
    container.id = 'pinyinInputBoxes';
    container.className = 'pinyin-input-boxes';
    document.getElementById('charContainer').appendChild(container);
  }
  
  // ✅ Toujours afficher le container en mode Pinyin
  container.style.display = 'flex';
  container.innerHTML = '';
  
  for (let i = 0; i < text.length; i++) {
    const box = document.createElement('div');
    box.className = 'pinyin-box';
    if (i === currentCharacterIndex) box.classList.add('active');
    box.dataset.index = i;
    
    box.addEventListener('click', () => {
      currentCharacterIndex = i;
      updatePinyinInputBoxes();
    });
    
    container.appendChild(box);
  }
  
  document.addEventListener('keydown', handlePinyinArrowKeys);
}

function handlePinyinArrowKeys(e) {
  if (!isPinyinGameMode() || pinyinValidated) return;
  
  const word = pinyinSelectedWords[currentPinyinWordIndex];
  const clean = stripPunct(word.text);
  
  if (e.key === 'ArrowLeft') {
    e.preventDefault();
    if (currentCharacterIndex > 0) {
      currentCharacterIndex--;
      updatePinyinInputBoxes();
    }
  } else if (e.key === 'ArrowRight') {
    e.preventDefault();
    if (currentCharacterIndex < clean.length - 1) {
      currentCharacterIndex++;
      updatePinyinInputBoxes();
    }
  }
}

function updatePinyinInputBoxes() {
  const boxes = document.querySelectorAll('.pinyin-box');
  boxes.forEach((box, i) => {
    box.textContent = pinyinInput[i] || '';
    box.classList.remove('active');
    if (i === currentCharacterIndex && !pinyinValidated) {
      box.classList.add('active');
    }
  });
}

// ===== Clavier AZERTY =====

function showPinyinKeyboard() {
let keyboard = document.getElementById('pinyinKeyboard');
  if (!keyboard) {
    keyboard = document.createElement('div');
    keyboard.id = 'pinyinKeyboard';
    document.getElementById('displayPage').appendChild(keyboard);
  }
  
  // Appliquer la couleur de fond adaptée
  const pageBg = getContrastingColor(bgColorPicker?.getColor()?.toHEXA().toString() || '#ffffff');
  const isDark = pageBg === '#ffffff';
  keyboard.style.background = isDark ? 'rgba(255,255,255,0.18)' : 'rgba(0,0,0,0.18)';
  
  keyboard.innerHTML = `
    <div class="keyboard-row">
      ${createKeyButton('a')}${createKeyButton('z')}${createKeyButton('e')}${createKeyButton('r')}${createKeyButton('t')}${createKeyButton('y')}${createKeyButton('u')}${createKeyButton('i')}${createKeyButton('o')}${createKeyButton('p')}
    </div>
    <div class="keyboard-row">
      ${createKeyButton('q')}${createKeyButton('s')}${createKeyButton('d')}${createKeyButton('f')}${createKeyButton('g')}${createKeyButton('h')}${createKeyButton('j')}${createKeyButton('k')}${createKeyButton('l')}${createKeyButton('m')}
    </div>
    <div class="keyboard-row">
      ${createKeyButton('w')}${createKeyButton('x')}${createKeyButton('c')}${createKeyButton('v')}${createKeyButton('b')}${createKeyButton('n')}
    </div>
    <div class="keyboard-row">
      <button class="key-btn backspace wide" data-key="backspace">⌫</button>
      <button class="key-btn validate wide" data-key="validate">Valider</button>
    </div>
    <div class="tone-picker" id="tonePicker"></div>
  `;
  
  keyboard.style.display = 'block';
  
  // Event listeners
  keyboard.querySelectorAll('.key-btn').forEach(btn => {
    btn.addEventListener('click', handleKeyboardClick);
  });
}

function createKeyButton(letter) {
  return `<button class="key-btn" data-key="${letter}">${letter.toUpperCase()}</button>`;
}

const VOWELS = ['a', 'e', 'i', 'o', 'u'];
const TONES = {
  'a': ['ā', 'á', 'ǎ', 'à', 'a'],
  'e': ['ē', 'é', 'ě', 'è', 'e'],
  'i': ['ī', 'í', 'ǐ', 'ì', 'i'],
  'o': ['ō', 'ó', 'ǒ', 'ò', 'o'],
  'u': ['ū', 'ú', 'ǔ', 'ù', 'u'],
  'ü': ['ǖ', 'ǘ', 'ǚ', 'ǜ', 'ü']
};

function handleKeyboardClick(e) {
  const key = e.target.dataset.key;
  if (!key) return;

  const picker = document.getElementById('tonePicker');
  const isPickerActive = picker && picker.classList.contains('active');
  const VOWELS = ['a', 'e', 'i', 'o', 'u'];

  // --- Si le tone picker est ouvert ---
  // ✅ 'validate' et 'space' valident le ton sélectionné
  if (isPickerActive && (key === 'validate' || key === 'space')) {
    const options = picker.querySelectorAll('.tone-option');
    if (options.length) {
      options[selectedToneIndex]?.click();
    }
    return;
  }

  // Si le picker est ouvert et on clique une touche non-voyelle (hors u/backspace/validate/space),
  // on prend la voyelle "de base" puis on ferme (fallback)
  if (isPickerActive && !VOWELS.includes(key) &&
      key !== 'u' && key !== 'backspace' && key !== 'validate' && key !== 'space' && key !== 'delete') {
    const base = picker.dataset.vowel || 'a';
    pinyinInput[currentCharacterIndex] += (base === 'ü' ? 'u' : base);
    updatePinyinInputBoxes();
    picker.classList.remove('active');
    picker.dataset.vowel = '';
    selectedToneIndex = 0;
  }

  // --- u / ü chooser ---
  const uChooser = document.getElementById('uChooser');
  const isUChooserActive = uChooser && uChooser.classList.contains('active');
  if (isUChooserActive) {
    if (key === 'u') {
      pinyinInput[currentCharacterIndex] += 'u';
      updatePinyinInputBoxes();
      uChooser.classList.remove('active');
      return;
    } else if (key === 'v') {
      pinyinInput[currentCharacterIndex] += 'ü';
      updatePinyinInputBoxes();
      uChooser.classList.remove('active');
      return;
    } else if (key === 'validate' || key === 'space') {
      // défaut = 'u'
      pinyinInput[currentCharacterIndex] += 'u';
      updatePinyinInputBoxes();
      uChooser.classList.remove('active');
      return;
    }
    // sinon on continue (ex: consonne) et on a déjà inséré 'u' ci-dessus?
  }

  // --- Touches spéciales de l'UI ---
  if (key === 'backspace') {
    if (pinyinInput[currentCharacterIndex]?.length > 0) {
      pinyinInput[currentCharacterIndex] =
        pinyinInput[currentCharacterIndex].slice(0, -1);
      updatePinyinInputBoxes();
    }
    return;
  }

  // (Optionnel si tu ajoutes un bouton Suppr à l'écran)
  if (key === 'delete') {
    pinyinInput[currentCharacterIndex] = '';
    updatePinyinInputBoxes();
    return;
  }

  if (key === 'validate' || key === 'space') {
    if (pinyinInput[currentCharacterIndex]?.length > 0) {
      moveToNextCharacter();
    }
    return;
  }

  // --- Lettres ---
  if (VOWELS.includes(key)) {
    showTonePicker(key, e.target);
    return;
  } else if (key === 'u') {
    showUChoice(e.target);
    return;
  }

  // Consonne simple
  pinyinInput[currentCharacterIndex] += key;
  updatePinyinInputBoxes();
}



function flashKey(key) {
  const keyBtn = document.querySelector(`.key-btn[data-key="${key}"]`);
  if (keyBtn) {
    keyBtn.classList.add('flash');
    setTimeout(() => keyBtn.classList.remove('flash'), 200);
  }
}

function setupPhysicalKeyboard() {
  // Désactiver si pas en mode pinyin clavier
  if (!isPinyinGameMode() || pinyinMode !== 'keyboard') return;
  
  document.addEventListener('keydown', handlePhysicalKeyboard);
}

function handlePhysicalKeyboard(e) {
  if (!isPinyinGameMode() || pinyinMode !== 'keyboard' || pinyinValidated) return;

  const picker = document.getElementById('tonePicker');
  const isPickerActive = picker && picker.classList.contains('active');

  const key = e.key;
  const keyLower = key.length === 1 ? key.toLowerCase() : key;
  const isSpace = (key === ' ' || e.code === 'Space');
  const VOWELS = ['a', 'e', 'i', 'o', 'u'];

  // ✅ compatibilité AZERTY : touches & é " ' (
  const TONE_KEYS = ['1', '2', '3', '4', '5'];
  const NUMPAD_KEYS = ['Numpad1', 'Numpad2', 'Numpad3', 'Numpad4', 'Numpad5'];
  const AZERTY_KEYS = ['&', 'é', '"', "'", '(']; // pour clavier français

  if (isPickerActive) {
    const options = picker.querySelectorAll('.tone-option');
    const baseVowel = picker.dataset.vowel || pendingVowel || 'a';

    // Flèches pour naviguer
    if (key === 'ArrowDown' || key === 'ArrowUp') {
      e.preventDefault();
      if (!options.length) return;
      options[selectedToneIndex]?.classList.remove('selected');
      selectedToneIndex =
        key === 'ArrowDown'
          ? (selectedToneIndex + 1) % options.length
          : (selectedToneIndex - 1 + options.length) % options.length;
      options[selectedToneIndex].classList.add('selected');
      return;
    }

    // Entrée / Espace → valident le ton sélectionné
    if (key === 'Enter' || isSpace) {
      e.preventDefault();
      if (options[selectedToneIndex]) options[selectedToneIndex].click();
      return;
    }

    // ✅ Nouvelles touches de ton (1–5, numpad1–5, ou &é"'()
    if (TONE_KEYS.includes(key) || NUMPAD_KEYS.includes(e.code) || AZERTY_KEYS.includes(key)) {
      e.preventDefault();
      // Trouver l’index selon la touche pressée
      let index = TONE_KEYS.includes(key)
        ? parseInt(key, 10) - 1
        : AZERTY_KEYS.indexOf(key);
      if (index < 0) index = parseInt(e.code.replace('Numpad', ''), 10) - 1;

      const toneList = TONES[baseVowel];
      if (toneList && toneList[index]) {
        pinyinInput[currentCharacterIndex] += toneList[index];
        updatePinyinInputBoxes();
      } else {
        // ton neutre ou invalide
        pinyinInput[currentCharacterIndex] += (baseVowel === 'ü' ? 'u' : baseVowel);
        updatePinyinInputBoxes();
      }

      picker.classList.remove('active');
      picker.dataset.vowel = '';
      selectedToneIndex = 0;
      tonePickerOpen = false;
      pendingVowel = null;
      return;
    }

    // Taper une autre lettre = fermer la fenêtre
    if (/^[a-z]$/i.test(keyLower)) {
      e.preventDefault();
      pinyinInput[currentCharacterIndex] += (baseVowel === 'ü' ? 'u' : baseVowel);
      updatePinyinInputBoxes();
      picker.classList.remove('active');
      picker.dataset.vowel = '';
      selectedToneIndex = 0;
      tonePickerOpen = false;
      pendingVowel = null;
    }
  }

  // Édition / validation / saisie standard
  if (key === 'Backspace') {
    e.preventDefault();
    flashKey('backspace');
    if (pinyinInput[currentCharacterIndex]?.length > 0) {
      pinyinInput[currentCharacterIndex] =
        pinyinInput[currentCharacterIndex].slice(0, -1);
      updatePinyinInputBoxes();
    }
    return;
  }

  if (key === 'Delete') {
    e.preventDefault();
    pinyinInput[currentCharacterIndex] = '';
    updatePinyinInputBoxes();
    return;
  }

  if (key === 'Enter' || isSpace) {
    e.preventDefault();
    if (pinyinInput[currentCharacterIndex]?.length > 0) {
      flashKey('validate');
      moveToNextCharacter();
    }
    return;
  }

  if (/^[a-z]$/.test(keyLower)) {
    e.preventDefault();
    flashKey(keyLower);

    if (VOWELS.includes(keyLower)) {
      const keyBtn = document.querySelector(`.key-btn[data-key="${keyLower}"]`);
      if (keyBtn) showTonePicker(keyLower, keyBtn);
      return;
    }

    if (keyLower === 'u') {
      const keyBtn = document.querySelector(`.key-btn[data-key="u"]`);
      if (keyBtn) showUChoice(keyBtn);
      return;
    }

    pinyinInput[currentCharacterIndex] += keyLower;
    updatePinyinInputBoxes();
    return;
  }
}



function removePhysicalKeyboard() {
  document.removeEventListener('keydown', handlePhysicalKeyboard);
}

function showTonePicker(vowel, buttonElement) {
  const picker = document.getElementById('tonePicker');
  picker.innerHTML = '';

  // Mémoriser la voyelle de base pour les validations au clavier
  picker.dataset.vowel = vowel;

  const tones = TONES[vowel];
  tones.forEach(tone => {
    const btn = document.createElement('button');
    btn.className = 'tone-option';
    btn.textContent = tone;
    btn.addEventListener('click', () => {
      // Choix du ton -> on ajoute la voyelle accentuée
      pinyinInput[currentCharacterIndex] += tone;
      updatePinyinInputBoxes();
      // Fermer le picker et reset état
      picker.classList.remove('active');
      picker.dataset.vowel = '';
      selectedToneIndex = 0;
      tonePickerOpen = false;
      pendingVowel = null;
    });
    picker.appendChild(btn);
  });

  // Sélection visuelle par défaut (index 0)
  selectedToneIndex = 0;
  const opts = picker.querySelectorAll('.tone-option');
  if (opts[0]) opts[0].classList.add('selected');

  tonePickerOpen = true;
  pendingVowel = vowel;

  // Positionner le picker au-dessus de la touche cliquée
  const rect = buttonElement.getBoundingClientRect();
  const keyboardRect = document.getElementById('pinyinKeyboard').getBoundingClientRect();
  picker.style.left = (rect.left - keyboardRect.left) + 'px';
  picker.style.bottom = (keyboardRect.bottom - rect.top + 10) + 'px';
  picker.classList.add('active');
}


function showUChoice(buttonElement) {
  const picker = document.getElementById('tonePicker');
  picker.innerHTML = '';
  
  ['u', 'ü'].forEach(letter => {
    const btn = document.createElement('button');
    btn.className = 'tone-option';
    btn.textContent = letter;
    btn.addEventListener('click', () => {
      picker.classList.remove('active');
      if (letter === 'ü') {
        showTonePicker('ü', buttonElement);
      } else {
        showTonePicker('u', buttonElement);
      }
    });
    picker.appendChild(btn);
  });
  
  const rect = buttonElement.getBoundingClientRect();
  const keyboardRect = document.getElementById('pinyinKeyboard').getBoundingClientRect();
  picker.style.left = (rect.left - keyboardRect.left) + 'px';
  picker.style.bottom = (keyboardRect.bottom - rect.top + 10) + 'px';
  picker.classList.add('active');
}

function moveToNextCharacter() {
  currentCharacterIndex++;
  
  const word = pinyinSelectedWords[currentPinyinWordIndex];
  const clean = stripPunct(word.text);
  
  if (currentCharacterIndex >= clean.length) {
    // Tous les caractères sont saisis, valider le mot
    validatePinyinWord();
  } else {
    updatePinyinInputBoxes();
  }
}

// ===== Tons avec lettres =====

function showToneSelection(text) {
  let container = document.getElementById('toneSelection');
  if (!container) {
    container = document.createElement('div');
    container.id = 'toneSelection';
    document.getElementById('displayPage').appendChild(container);
  }
  
  const word = pinyinSelectedWords[currentPinyinWordIndex];
  const pinyinSyllables = getPinyinSyllables(word);
  
  if (pinyinMode === 'toneWithLetters') {
    displayToneWithLetters(container, pinyinSyllables);
  } else {
    displayToneOnly(container);
  }
  
  container.style.display = 'block';
  
  // Cacher le clavier si affiché
  const keyboard = document.getElementById('pinyinKeyboard');
  if (keyboard) keyboard.style.display = 'none';
}

function getPinyinSyllables(token) {
  if (!token.pinyin) return [];
  // Le pinyin peut contenir plusieurs syllabes séparées par des espaces
  return token.pinyin.split(' ');
}

function displayToneWithLetters(container, syllables) {
  const currentSyllable = syllables[currentCharacterIndex] || '';
  const baseLetters = removeTone(currentSyllable);
  
  // Générer toutes les variations avec tons
  const variations = generateToneVariations(baseLetters);
  
  // Appliquer les couleurs de fond adaptées
  const pageBg = getContrastingColor(bgColorPicker?.getColor()?.toHEXA().toString() || '#ffffff');
  const isDark = pageBg === '#ffffff';
  const btnBg = isDark ? 'rgba(255,255,255,0.18)' : 'rgba(0,0,0,0.18)';
  const btnColor = isDark ? '#ffffff' : '#000000';
  
container.innerHTML = `
  <div class="tone-cross-container" style="position: relative; width: 240px; height: 240px; margin: 0 auto; transform: translateY(18px);">
      <!-- Haut : 1er ton -->
      <button class="tone-btn" style="position: absolute; top: 0; left: 50%; transform: translateX(-50%); background: ${btnBg}; color: ${btnColor}; width: 70px; height: 70px; font-size: 22px;" data-index="0" title="1er ton">${variations[0] || ''}</button>
      
      <!-- Gauche : 2e ton -->
      <button class="tone-btn" style="position: absolute; left: 0; top: 50%; transform: translateY(-50%); background: ${btnBg}; color: ${btnColor}; width: 70px; height: 70px; font-size: 22px;" data-index="1" title="2e ton">${variations[1] || ''}</button>
      
      <!-- Centre : ton neutre -->
      <button class="tone-btn" style="position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); background: ${btnBg}; color: ${btnColor}; width: 70px; height: 70px; font-size: 22px;" data-index="4" title="Ton neutre">${variations[4] || ''}</button>
      
      <!-- Droite : 4e ton -->
      <button class="tone-btn" style="position: absolute; right: 0; top: 50%; transform: translateY(-50%); background: ${btnBg}; color: ${btnColor}; width: 70px; height: 70px; font-size: 22px;" data-index="3" title="4e ton">${variations[3] || ''}</button>
      
      <!-- Bas : 3e ton -->
      <button class="tone-btn" style="position: absolute; bottom: 0; left: 50%; transform: translateX(-50%); background: ${btnBg}; color: ${btnColor}; width: 70px; height: 70px; font-size: 22px;" data-index="2" title="3e ton">${variations[2] || ''}</button>
    </div>
  `;
  
  container.querySelectorAll('.tone-btn').forEach(btn => {
    btn.addEventListener('click', () => {
      const index = parseInt(btn.dataset.index);
      const variant = variations[index];
      
      pinyinInput[currentCharacterIndex] = variant;
      currentCharacterIndex++;
      updatePinyinInputBoxes();
      
      const word = pinyinSelectedWords[currentPinyinWordIndex];
      const clean = stripPunct(word.text);
      
      if (currentCharacterIndex >= clean.length) {
        validatePinyinWord();
      } else {
        displayToneWithLetters(container, syllables);
      }
    });
  });
}

function displayToneOnly(container) {
  // Appliquer les couleurs de fond adaptées
  const pageBg = getContrastingColor(bgColorPicker?.getColor()?.toHEXA().toString() || '#ffffff');
  const isDark = pageBg === '#ffffff';
  const btnBg = isDark ? 'rgba(255,255,255,0.18)' : 'rgba(0,0,0,0.18)';
  const btnColor = isDark ? '#ffffff' : '#000000';
  
container.innerHTML = `
   <div class="tone-cross-container" style="position: relative; width: 240px; height: 240px; margin: 0 auto; transform: translateY(18px);">
    <!-- Haut : 1er ton (¯) -->
    <button class="tone-btn" style="position: absolute; top: 0; left: 50%; transform: translateX(-50%); background: ${btnBg}; color: ${btnColor}; width: 70px; height: 70px; font-size: 44px;" data-tone="1" title="1er ton">¯</button>
    
    <!-- Gauche : 2e ton (´) -->
    <button class="tone-btn" style="position: absolute; left: 0; top: 50%; transform: translateY(-50%); background: ${btnBg}; color: ${btnColor}; width: 70px; height: 70px; font-size: 44px;" data-tone="2" title="2e ton">´</button>
    
    <!-- Centre : ton neutre (·) -->
    <button class="tone-btn" style="position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); background: ${btnBg}; color: ${btnColor}; width: 70px; height: 70px; font-size: 44px;" data-tone="5" title="Ton neutre">·</button>
    
    <!-- Droite : 4e ton (\`) -->
    <button class="tone-btn" style="position: absolute; right: 0; top: 50%; transform: translateY(-50%); background: ${btnBg}; color: ${btnColor}; width: 70px; height: 70px; font-size: 44px;" data-tone="4" title="4e ton">\`</button>
    
    <!-- Bas : 3e ton (ˇ) -->
    <button class="tone-btn" style="position: absolute; bottom: 0; left: 50%; transform: translateX(-50%); background: ${btnBg}; color: ${btnColor}; width: 70px; height: 70px; font-size: 44px;" data-tone="3" title="3e ton">ˇ</button>
  </div>
`;
  
  const toneMarks = ['¯', '´', 'ˇ', '`', '·'];
  
  container.querySelectorAll('.tone-btn').forEach(btn => {
    const toneIndex = parseInt(btn.dataset.tone) - 1;
    btn.addEventListener('click', () => {
      pinyinInput[currentCharacterIndex] = toneMarks[toneIndex === 4 ? 4 : toneIndex];
      currentCharacterIndex++;
      updatePinyinInputBoxes();
      
      const word = pinyinSelectedWords[currentPinyinWordIndex];
      const clean = stripPunct(word.text);
      
      if (currentCharacterIndex >= clean.length) {
        validatePinyinWord();
      }
    });
  });
}

function removeTone(pinyin) {
  const toneChars = {
    'ā':'a', 'á':'a', 'ǎ':'a', 'à':'a',
    'ē':'e', 'é':'e', 'ě':'e', 'è':'e',
    'ī':'i', 'í':'i', 'ǐ':'i', 'ì':'i',
    'ō':'o', 'ó':'o', 'ǒ':'o', 'ò':'o',
    'ū':'u', 'ú':'u', 'ǔ':'u', 'ù':'u',
    'ǖ':'ü', 'ǘ':'ü', 'ǚ':'ü', 'ǜ':'ü'
  };
  
  return pinyin.split('').map(c => toneChars[c] || c).join('');
}

function getMainVowel(pinyin) {
  const priority = ['a', 'e', 'o'];
  for (const v of priority) {
    if (pinyin.includes(v)) return v;
  }
  if (pinyin.includes('iu')) return 'u';
  if (pinyin.includes('ui')) return 'i';
  for (const v of ['i', 'u', 'ü']) {
    if (pinyin.includes(v)) return v;
  }
  return 'a';
}

function generateToneVariations(base) {
  const mainVowel = getMainVowel(base);
  const tones = TONES[mainVowel];
  if (!tones) return [base, base, base, base, base];
  
  const variations = [];
  for (let i = 0; i < 5; i++) {
    // Trouver l'index de la voyelle principale dans la chaîne
    const vowelIndex = base.indexOf(mainVowel);
    if (vowelIndex === -1) {
      variations.push(base);
    } else {
      // Remplacer uniquement la première occurrence
      const variant = base.substring(0, vowelIndex) + tones[i] + base.substring(vowelIndex + 1);
      variations.push(variant);
    }
  }
  return variations;
}

// ===== Validation =====

function validatePinyinWord() {
  const word = pinyinSelectedWords[currentPinyinWordIndex];
  if (!word) return;

  const clean = stripPunct(word.text);
  let isCorrect = false;

  if (pinyinMode === 'toneOnly') {
    const expectedToneCount = clean.length;
    const userTones = pinyinInput.join('');
    const correctPinyin = word.pinyin || '';
    const correctTones = extractTones(correctPinyin);
    isCorrect = (
      userTones.length === expectedToneCount &&
      correctTones.length === expectedToneCount &&
      correctTones === userTones
    );
  } else {
    const correctPinyin = word.pinyin
      ? word.pinyin.replace(/\s+/g, '').replace(/[，。！？,.!?;；:：]/g, '')
      : '';
    const userPinyin = pinyinInput.join('').replace(/[，。！？,.!?;；:：]/g, '');
    isCorrect = normalizePinyin(correctPinyin) === normalizePinyin(userPinyin);
  }

  pinyinValidated = true;

  if (isCorrect) {
    displayPinyinSequence(word);
    return;
  }

  
  // ❌ MAUVAISE RÉPONSE
  const boxes = Array.from(document.querySelectorAll('.pinyin-input-box, .pinyin-box'));
  boxes.forEach(b => {
    b.classList.remove('active', 'correct');
    b.classList.add('incorrect');
    b.style.backgroundColor = 'rgba(255,255,255,0.9)';
    b.style.borderColor = '#ef4444';
    b.style.color = '#ef4444';
    b.style.outline = '3px solid #ef4444';
    b.style.outlineOffset = '0px';
    b.style.boxShadow = '0 0 6px rgba(239,68,68,0.8)';
  });

  const charDisplay = document.getElementById('charDisplay');
  if (charDisplay) {
    charDisplay.style.opacity = '1';
    charDisplay.style.visibility = 'visible';
  }

  setTimeout(() => {
    boxes.forEach(b => {
      b.classList.remove('incorrect');
      b.style.color = '';
      b.style.border = '';
      b.style.borderColor = '';
      b.style.outline = '';
      b.style.outlineOffset = '';
      b.style.boxShadow = '';
      b.style.backgroundColor = '';
    });

    pinyinInput = new Array(clean.length).fill('');
    currentCharacterIndex = 0;
    pinyinValidated = false;
    updatePinyinInputBoxes();

    if (pinyinMode === 'keyboard') {
      showPinyinKeyboard();
    } else {
      showToneSelection(clean);
    }
  }, 1000);
}

function advanceToNextPinyinWord() {
  // Cacher toutes les interfaces de saisie
  const inputBoxes = document.getElementById('pinyinInputBoxes');
  const keyboard = document.getElementById('pinyinKeyboard');
  const toneSelection = document.getElementById('toneSelection');
  const pEl = document.getElementById('pinyin');
  const dEl = document.getElementById('defs');
  
  if (inputBoxes) inputBoxes.style.display = 'none';
  if (keyboard) keyboard.style.display = 'none';
  if (toneSelection) toneSelection.style.display = 'none';
  if (pEl) { pEl.style.display = 'none'; pEl.textContent = ''; }
  if (dEl) { dEl.style.display = 'none'; dEl.textContent = ''; }
  
  // Passer au mot suivant
  currentPinyinWordIndex++;
  showPinyinWord();
}

function displayPinyinSequence(word) {

  
  // Annuler tout timer précédent
  if (autoNextTimer) {

    clearTimeout(autoNextTimer);
  }
  if (showDefsTimer) {

    clearTimeout(showDefsTimer);
  }
  autoNextTimer = null;
  showDefsTimer = null;

  const boxes = document.querySelectorAll('.pinyin-box');
  const pEl = document.getElementById('pinyin');
  const dEl = document.getElementById('defs');
  const normalText = (textColorPicker?.getColor()?.toHEXA().toString()) || '#000000';

  // Mise en forme des cases : vert
  boxes.forEach(box => {
    box.classList.remove('active', 'incorrect');
    box.classList.add('correct');
    box.style.background = '#10b981';
    box.style.color = '#ffffff';
    box.style.opacity = '1';
  });

  const isFastMode = isFastRevealEnabled();
  const delayMs = isFastMode ? 1000 : 3000;
  

  // Mode rapide
  if (isFastMode && pinyinFlow === 'selectedOnly') {
    
    if (pEl) { pEl.textContent = ''; pEl.style.display = 'none'; }
    if (dEl) { dEl.textContent = ''; dEl.style.display = 'none'; }
    
    const charDisplay = document.getElementById('charDisplay');
    const keyboard = document.getElementById('pinyinKeyboard');
    const toneSelection = document.getElementById('toneSelection');
    
    setTimeout(() => {
      if (charDisplay) charDisplay.style.opacity = '0';
      boxes.forEach(box => box.style.opacity = '0');
      if (keyboard) keyboard.style.opacity = '0';
      if (toneSelection) toneSelection.style.opacity = '0';
    }, 1000);

    autoNextTimer = setTimeout(() => {
      
      if (charDisplay) charDisplay.style.opacity = '1';
      boxes.forEach(box => box.style.opacity = '1');
      if (keyboard) keyboard.style.opacity = '1';
      if (toneSelection) toneSelection.style.opacity = '1';
      
      advanceToNextPinyinWord();
    }, 1000);
    
    return;
  }

  // Mode normal
  
  if (pEl) { pEl.textContent = ''; pEl.style.display = 'none'; }
  if (dEl) { dEl.textContent = ''; dEl.style.display = 'none'; }

  if (pEl && word.pinyin) {
    pEl.textContent = word.pinyin;
    pEl.style.display = 'block';
    pEl.style.visibility = 'visible';
    pEl.style.color = normalText;
  }

  showDefsTimer = setTimeout(() => {
    if (dEl && word.defs) {
      dEl.textContent = word.defs.join(', ');
      dEl.style.display = 'block';
      dEl.style.visibility = 'visible';
      dEl.style.color = normalText;
    }
  }, 1000);

  autoNextTimer = setTimeout(() => {
    
    if (pinyinFlow === 'stopOnSelected' && pinyinGateActive) {
      const inputBoxes = document.getElementById('pinyinInputBoxes');
      if (inputBoxes) inputBoxes.style.display = 'none';
      const keyboard = document.getElementById('pinyinKeyboard');
      if (keyboard) keyboard.style.display = 'none';
      const toneSelection = document.getElementById('toneSelection');
      if (toneSelection) toneSelection.style.display = 'none';
      if (pEl) { pEl.style.display = 'none'; pEl.textContent = ''; }
      if (dEl) { dEl.style.display = 'none'; dEl.textContent = ''; }

      resumeAfterPinyinGate();
    } else if (pinyinFlow === 'selectedOnly') {
      advanceToNextPinyinWord();
    }
  }, 3000);
  
}


function displayPinyinResult(isCorrect) {
  const boxes = document.querySelectorAll('.pinyin-box');
  boxes.forEach(box => {
    box.classList.remove('active', 'incorrect', 'correct'); // nettoie
    if (isCorrect) {
      // succès = style vert existant
      box.classList.add('correct');
      box.style.background = '#10b981';
      box.style.color = '#ffffff';
    } else {
      // erreur = fond blanc, texte rouge (temporaire)
      box.style.background = 'rgba(255,255,255,0.9)';
      box.style.borderColor = '#d1d5db';
      box.style.color = '#ef4444';
    }
  });
}


function normalizePinyin(pinyin) {
  // Supprimer les espaces ET la ponctuation
  return pinyin.toLowerCase().replace(/\s+/g, '').replace(/[，。！？,.!?;；:：]/g, '');
}

function compareTones(correctPinyin, userTones) {
  const correctTones = extractTones(correctPinyin);
  return correctTones === userTones;
}

function extractTones(pinyin) {
  const toneMap = {
    'ā': '¯', 'á': '´', 'ǎ': 'ˇ', 'à': '`',
    'ē': '¯', 'é': '´', 'ě': 'ˇ', 'è': '`',
    'ī': '¯', 'í': '´', 'ǐ': 'ˇ', 'ì': '`',
    'ō': '¯', 'ó': '´', 'ǒ': 'ˇ', 'ò': '`',
    'ū': '¯', 'ú': '´', 'ǔ': 'ˇ', 'ù': '`',
    'ǖ': '¯', 'ǘ': '´', 'ǚ': 'ˇ', 'ǜ': '`'
  };
  
  // Nettoyer ponctuation mais GARDER les espaces pour compter les syllabes
  const cleaned = pinyin.replace(/[，。！？,.!?;；:：""''（）()【】\[\]]/g, '');
  
  // Séparer en syllabes (par espaces)
  const syllables = cleaned.split(/\s+/).filter(s => s.length > 0);
  
  let tones = '';
  
  for (const syllable of syllables) {
    let foundTone = false;
    
    // Chercher un ton dans cette syllabe
    for (const char of syllable) {
      if (toneMap[char]) {
        tones += toneMap[char];
        foundTone = true;
        break; // Une seule voyelle tonique par syllabe
      }
    }
    
    // Si pas de ton trouvé = ton neutre
    if (!foundTone) {
      tones += '·';
    }
  }
  
  return tones;
}

function goToPreviousPinyinWord() {
  if (currentPinyinWordIndex > 0) {
    currentPinyinWordIndex--;
    showPinyinWord();
  }
}

function goToNextPinyinWord() {
  if (currentPinyinWordIndex < pinyinSelectedWords.length - 1) {
    currentPinyinWordIndex++;
    showPinyinWord();
  }
}

function quitPinyinGame() {
  // Nettoyer l'interface pinyin
  const keyboard = document.getElementById('pinyinKeyboard');
  const toneSelection = document.getElementById('toneSelection');
  const inputBoxes = document.getElementById('pinyinInputBoxes');
  
  if (keyboard) keyboard.remove();
  if (toneSelection) toneSelection.remove();
  if (inputBoxes) inputBoxes.remove();
  
  // Réinitialiser les variables
  pinyinSelectedWords = [];
  currentPinyinWordIndex = 0;
  currentCharacterIndex = 0;
  pinyinInput = [];
  pinyinValidated = false;
  
  // Retour à l'accueil
  forcePause();
  togglePinyinBars(false);  // ← Ajouter cette ligne
  document.getElementById('displayPage').style.display = 'none';
  document.getElementById('homePage').style.display = 'block';
  removePhysicalKeyboard();
}

function updatePinyinPlayIcon() {
  const btn = document.getElementById('playPinyinBtn');
  if (!btn) return;

  if (playing) {
    btn.innerHTML = `
      <svg class="icon" viewBox="0 0 24 24" fill="currentColor">
        <rect x="7" y="6" width="3" height="12"></rect>
        <rect x="14" y="6" width="3" height="12"></rect>
      </svg>`;
  } else {
    btn.innerHTML = `
      <svg class="icon" viewBox="0 0 24 24" fill="currentColor">
        <polygon points="8,6 18,12 8,18"></polygon>
      </svg>`;
  }
}

// ========= Modification de startDisplay() pour gérer le mode pinyin =========
function startDisplay() {
  const text = normalizeChineseText(document.getElementById('inputText').value);
  tokens = attachDictInfo(segmentText(text, dict.wordSet, dict.maxLen), dict.entries);
  idx = 0;

  if (!tokens.length) {
    alert("Aucun mot à afficher.");
    return;
  }

  // Mode reorderNoRead
  if (gameMode && gameType === 'reorderNoRead') {
    document.getElementById('homePage').style.display = 'none';
    
    sentenceStarts = computeSentenceStarts(tokens);
    playedSentences = [];
    currentSentenceIndex = Math.floor(Math.random() * sentenceStarts.length);
    playedSentences.push(currentSentenceIndex);
    idx = sentenceStarts[currentSentenceIndex];
    originalSentence = getSentenceText(tokens, currentSentenceIndex);
    
    const bgColor = (bgColorPicker?.getColor()?.toHEXA().toString()) || '#ffffff';
    document.body.style.backgroundColor = bgColor;
    
    openGamePlayOverlayDirect();
    return;
  }

  // Mode Pinyin
  if (isPinyinGameMode()) {
    document.getElementById('homePage').style.display = 'none';
    const dp = document.getElementById('displayPage');
    dp.style.display = 'block';
    dp.style.visibility = 'visible';
    
    const initialBg = (bgColorPicker?.getColor()?.toHEXA().toString()) || '#ffffff';
    const contrast0 = getContrastingColor(initialBg);
    applyControlsTheme(contrast0);
    
    // Initialiser le jeu pinyin
    if (!initPinyinGame()) {
      document.getElementById('displayPage').style.display = 'none';
      document.getElementById('homePage').style.display = 'block';
      return;
    }
    
    // Afficher les barres de navigation pinyin
    togglePinyinBars(true);
    
    // 🚫 JAMAIS de lecture auto en selectedOnly
    forcePause();
    
    return;
  }
  
  // Mode normal avec page de lecture
  document.getElementById('homePage').style.display = 'none';
  const dp = document.getElementById('displayPage');
  dp.style.display = 'block';
  dp.style.visibility = 'visible';

  // En mode jeu, on réinitialise les mots surlignés
  // En mode lecture, on garde les mots déjà sélectionnés
  if (gameMode) {
    highlightWords = [];
  }

  const initialBg = (bgColorPicker?.getColor()?.toHEXA().toString()) || '#ffffff';
  const contrast0 = getContrastingColor(initialBg);
  applyControlsTheme(contrast0);

  wireInfoOverlayControls();

  if (gameMode) {
    sentenceStarts = computeSentenceStarts(tokens);
    playedSentences = [];
    currentSentenceIndex = 0;
    toggleGameBars(true);
    updateGameBarNavigation();
  } else {
    toggleGameBars(false);
    toggleGameBarsNoRead(false);
  }

  clearInterval(timer);
  playing = false;
  showToken(tokens[idx]);
  if (typeof fitCharLine === 'function') fitCharLine();
}

function togglePinyinBars(show) {
  const normalBar = document.getElementById('barDefault');
  const ghostBar = document.getElementById('ghostBar');
  const gameBars = document.getElementById('gameBars');
  const gameBarsNoRead = document.getElementById('gameBarsNoRead');
  const pinyinBars = document.getElementById('pinyinBars');
  const displayPage = document.getElementById('displayPage');
  
  if (show) {
    const playBtn = document.getElementById('playPinyinBtn');
    normalBar.style.display = 'none';
    ghostBar.style.display = 'none';
    gameBars.style.display = 'none';
    gameBarsNoRead.style.display = 'none';
	if (playBtn) {
      playBtn.style.visibility = (pinyinFlow === 'stopOnSelected') ? 'visible' : 'hidden';
    }
    pinyinBars.style.display = 'block';
    displayPage.classList.add('game-mode-active');
    
    // Appliquer les couleurs aux boutons pinyin
    const pageBg = (bgColorPicker?.getColor()?.toHEXA().toString()) || '#ffffff';
    const contrast = getContrastingColor(pageBg);
    const isDark = contrast === '#ffffff';
    
    pinyinBars.querySelectorAll('.game-btn').forEach(btn => {
      btn.style.color = contrast;
      btn.style.background = isDark ? 'rgba(255,255,255,0.18)' : 'rgba(0,0,0,0.18)';
      btn.style.borderColor = 'none';
    });
  } else {
    normalBar.style.display = 'grid';
    ghostBar.style.display = 'none';
    gameBars.style.display = 'none';
    gameBarsNoRead.style.display = 'none';
    pinyinBars.style.display = 'none';
    displayPage.classList.remove('game-mode-active');
  }
}

['visibilitychange','resize','orientationchange'].forEach(evt => {
  window.addEventListener(evt, () => {
    if (document.hidden) return;
    const pb = document.getElementById('pinyinBars');
    if (!pb) return;
    pb.style.position = 'fixed';
    pb.style.top = '';
    pb.style.bottom = 'calc(env(safe-area-inset-bottom, 0px) + 0px)';
    pb.style.left = '50%';
    pb.style.transform = 'translateX(-50%)';
  });
});

function openPinyinInfoOverlay() {
  const overlay = document.getElementById('infoOverlay');
  const body = document.getElementById('infoWords');
  if (!overlay || !body) return;
  
  forcePause();
  
  body.innerHTML = '';
  
  const normalBg = (bgColorPicker?.getColor()?.toHEXA().toString()) || '#ffffff';
  const normalText = (textColorPicker?.getColor()?.toHEXA().toString()) || '#000000';
  
  overlay.style.setProperty('--info-bg', normalBg);
  overlay.style.setProperty('--info-fg', normalText);
  
  // Afficher tous les tokens, mais rendre cliquables seulement les mots sélectionnés
  tokens.forEach((tok, i) => {
    const span = document.createElement('span');
    span.textContent = tok.text;
    span.className = 'info-word';
    
const clean = stripPunct(tok.text);
    
    // Vérifier si c'est un mot sélectionné
    const selectedIndex = pinyinSelectedWords.findIndex(w => {
const wClean = stripPunct(w.text);
      return wClean === clean;
    });
    
    if (selectedIndex >= 0) {
      span.classList.add('selectable');
      if (selectedIndex === currentPinyinWordIndex) span.classList.add('current');
      
      span.onclick = () => {
        currentPinyinWordIndex = selectedIndex;
        overlay.style.display = 'none';
        showPinyinWord();
      };
    }
    
    body.appendChild(span);
  });
  
  overlay.style.display = 'flex';
  showBackdrop();
}


// ========= Events =========
window.addEventListener('resize', fitCharLine);
window.addEventListener('orientationchange', () => setTimeout(fitCharLine, 50));

function wireGhostBar() {
  const map = {
    ghostPrev: 'prevWordBtn',
    ghostPause: 'pauseBtn',
    ghostNext: 'nextWordBtn'
  };
  for (const [ghostId, realId] of Object.entries(map)) {
    const g = document.getElementById(ghostId);
    const r = document.getElementById(realId);
    if (g && r) g.onclick = (e) => { e.preventDefault(); r.click(); };
  }
}

document.addEventListener('DOMContentLoaded', () => {
  const $ = s => document.querySelector(s);

  // Initialize UI
  updateUI();

  // Mode selection
  $('#readMode')?.addEventListener('change', () => {
    appMode = 'read';
    gameMode = false;
    updateUI();
  });
  
  $('#gameMode')?.addEventListener('change', () => {
    appMode = 'game';
    gameMode = true;
    updateUI();
  });
  
  // Game type selection
  document.querySelectorAll('input[name="gameType"]').forEach(radio => {
    radio.addEventListener('change', (e) => {
      gameType = e.target.value;
      updateUI();
    });
  });
  
// Pinyin sub-options selection
document.querySelectorAll('input[name="pinyinFlow"]').forEach(r => {
  r.addEventListener('change', (e) => { 
    pinyinFlow = e.target.value;
  });
  
  // ✅ IMPORTANT : Récupérer la valeur cochée au démarrage
  if (r.checked) {
    pinyinFlow = r.value;
  }
});

  // Vitesse
  $('#speed')?.addEventListener('input', e => {
    $('#speedLabel').textContent = e.target.value;
    if (playing) startLoop();
  });

  // Démarrer
$('#startBtn')?.addEventListener('click', () => {
  startDisplay();
  if (!isPinyinGameMode() && (!gameMode || gameType !== 'reorderNoRead')) {
    forcePlay(true);
  }
});

  // Play / Pause
  $('#pauseBtn')?.addEventListener('click', () => {
    if (!tokens || !tokens.length) return;
    if (idx >= tokens.length - 1) { restartFrom(0); forcePlay(); return; }
    if (playing) forcePause(); else forcePlay();
  });

  // Navigation mots
  $('#prevWordBtn')?.addEventListener('click', () => { 
    if (!tokens.length) return; 
    restartFrom(Math.max(0, idx - 1)); 
    forcePause(); 
  });
  
  $('#nextWordBtn')?.addEventListener('click', () => { 
    if (!tokens.length) return; 
    restartFrom(Math.min(tokens.length - 1, idx + 1)); 
    forcePause(); 
  });

  // Quitter
  $('#quitBtn')?.addEventListener('click', () => {
    forcePause();
    document.getElementById('charDisplay').innerHTML = '';
    document.getElementById('pinyin').textContent = '';
    document.getElementById('defs').textContent = '';
    idx = 0;
    document.getElementById('displayPage').style.display = 'none';
    document.getElementById('homePage').style.display = 'block';
  });

  // Quitter le mode jeu
  $('#quitGameBtn')?.addEventListener('click', () => {
    forcePause();
    document.getElementById('charDisplay').innerHTML = '';
    document.getElementById('pinyin').textContent = '';
    document.getElementById('defs').textContent = '';
    idx = 0;
    closeGameModeOverlay();
    closeGamePlayOverlay();
    document.getElementById('displayPage').style.display = 'none';
    toggleGameBars(false);
    toggleGameBarsNoRead(false);
    document.getElementById('homePage').style.display = 'block';
  });
  
  $('#quitGameNoReadBtn')?.addEventListener('click', () => {
    forcePause();
    closeGamePlayOverlay();
    document.body.style.backgroundColor = '';
    idx = 0;
    document.getElementById('homePage').style.display = 'block';
  });

  // MODE JEU : Barres de jeu
  $('#prevSentenceBtn')?.addEventListener('click', () => {
    goToPreviousSentence();
    forcePause();
  });
  
  $('#prevSentenceNoReadBtn')?.addEventListener('click', () => {
    goToPreviousSentence();
  });

  $('#showGameBtn')?.addEventListener('click', () => {
    openGameManually();
  });
  
  $('#showGameNoReadBtn')?.addEventListener('click', () => {
    openGameManually();
  });

  $('#nextSentenceBtn')?.addEventListener('click', () => {
    goToNextSentence();
    forcePause();
  });
  
  $('#nextSentenceNoReadBtn')?.addEventListener('click', () => {
    goToNextSentence();
  });
  
  $('#randomSentenceBtn')?.addEventListener('click', () => {
    goToRandomSentence();
  });

  $('#playGameBtn')?.addEventListener('click', () => {
    if (playing) {
      forcePause();
    } else {
      if (idx >= tokens.length - 1) {
        restartFrom(0);
      }
      forcePlay();
    }
    updatePlayGameBtnIcon();
  });

  // OVERLAY DE SÉLECTION DE MODE
  $('#reorderModeBtn')?.addEventListener('click', () => {
    openGamePlayOverlay('reorder');
  });

  $('#freeModeBtn')?.addEventListener('click', () => {
    openGamePlayOverlay('free');
  });

  $('#closeGameMode')?.addEventListener('click', () => {
    closeGameModeOverlay();
  });

  $('#prevSentenceGame')?.addEventListener('click', () => {
    goToPreviousSentence();
    closeGameModeOverlay();
  });

  $('#nextSentenceGame')?.addEventListener('click', () => {
    goToNextSentence();
    closeGameModeOverlay();
  });

  $('#replayGame')?.addEventListener('click', () => {
    replaySentence();
  });

  // OVERLAY DE JEU PRINCIPAL
  $('#closeGamePlay')?.addEventListener('click', () => {
    closeGamePlayOverlay();
    if (gameType === 'reorderNoRead') {
      document.body.style.backgroundColor = '';
      document.getElementById('homePage').style.display = 'block';
    }
  });

  $('#switchReorder')?.addEventListener('click', () => {
    switchGameMode('reorder');
  });

  $('#switchFree')?.addEventListener('click', () => {
    switchGameMode('free');
  });

  $('#validateReorder')?.addEventListener('click', () => {
    validateReorderGame();
  });

  $('#retryReorder')?.addEventListener('click', () => {
    initReorderGame();
  });

  $('#validateFree')?.addEventListener('click', () => {
    validateFreeGame();
  });

  $('#retryFree')?.addEventListener('click', () => {
    initFreeGame();
  });

  $('#prevSentenceInGame')?.addEventListener('click', () => {
    goToPreviousSentence();
    closeGamePlayOverlay();
  });

  $('#nextSentenceInGame')?.addEventListener('click', () => {
    goToNextSentence();
    closeGamePlayOverlay();
  });

  $('#replayInGame')?.addEventListener('click', () => {
    replaySentence();
  });

  $('#freeTextInput')?.addEventListener('keydown', (e) => {
    if (e.key === 'Enter' && e.ctrlKey) {
      e.preventDefault();
      validateFreeGame();
    }
  });

  // Overlay sélection
  $('#toggleEdit')?.addEventListener('click', openSelectionOverlay);
  
  // Mode Pinyin - Barres de navigation
  $('#quitPinyinBtn')?.addEventListener('click', () => {
    quitPinyinGame();
  });

  $('#nextPinyinWordBtn')?.addEventListener('click', () => {
    clearTimeout(autoNextTimer);
    autoNextTimer = null;
    clearTimeout(showDefsTimer);
    showDefsTimer = null;

    const p = document.getElementById('pinyin');
    const d = document.getElementById('defs');
    if (p) { p.textContent = ''; p.style.display = 'none'; }
    if (d) { d.textContent = ''; d.style.display = 'none'; }

    if (pinyinFlow === 'selectedOnly') {
      if (currentPinyinWordIndex < pinyinSelectedWords.length - 1) {
        currentPinyinWordIndex++;
        showPinyinWord();
      }
    } else {
      goToNextPinyinWord();
    }
  });

  $('#prevPinyinWordBtn')?.addEventListener('click', () => {
    clearTimeout(autoNextTimer);
    autoNextTimer = null;
    clearTimeout(showDefsTimer);
    showDefsTimer = null;

    const p = document.getElementById('pinyin');
    const d = document.getElementById('defs');
    if (p) { p.textContent = ''; p.style.display = 'none'; }
    if (d) { d.textContent = ''; d.style.display = 'none'; }

    if (pinyinFlow === 'selectedOnly') {
      if (currentPinyinWordIndex > 0) {
        currentPinyinWordIndex--;
        showPinyinWord();
      }
    } else {
      goToPreviousPinyinWord();
    }
  });

  $('#playPinyinBtn')?.addEventListener('click', () => {
    if (!playing) {
      forcePlay();
    } else {
      forcePause();
    }
  });

  $('#showPinyinInfoBtn')?.addEventListener('click', () => {
    openPinyinInfoOverlay();
  });
  
  $('#closeOverlay')?.addEventListener('click', closeSelectionOverlay);
  $('#overlayCancelBtn')?.addEventListener('click', closeSelectionOverlay);
  $('#overlayValidateBtn')?.addEventListener('click', () => {
    highlightWords = [...highlightWords];
    renderSegmented();
    closeSelectionOverlay();
  });

  $('#selectAllOverlay')?.addEventListener('click', () => {
    const text = normalizeChineseText(document.getElementById('inputText').value);
    const segmented = attachDictInfo(segmentText(text, dict.wordSet, dict.maxLen), dict.entries);
    
    const allWords = segmented
      .filter(tok => tok.type === 'han')
      .map(tok => stripPunct(tok.text));
    
    if (highlightWords.length === allWords.length) {
      highlightWords = [];
    } else {
      highlightWords = [...allWords];
    }
    
    openSelectionOverlay();
  });

  // Effacer
  $('#clearText')?.addEventListener('click', () => {
    const input = document.getElementById('inputText');
    if (!input) return;
    input.value = '';
    renderSegmented();
  });

  // Hamburger
  let hamburgerTimeout = null;
  const hamburger = document.getElementById('hamburger');
  if (hamburger) {
    hamburger.addEventListener('click', (e) => {
      e.preventDefault();
      e.stopPropagation();
      if (hamburgerTimeout) return;
      hamburgerTimeout = setTimeout(() => hamburgerTimeout = null, 200);
      if (__menuHiddenByUser) {
        showMenu();
        __menuHiddenByUser = false;
      } else {
        hideMenu();
        __menuHiddenByUser = true;
      }
    });
  }

  // Saisie / collage
  $('#inputText')?.addEventListener('paste', () => {
    setTimeout(() => {
      const input = document.getElementById('inputText');
      input.value = normalizeChineseText(input.value);
      renderSegmented();
    }, 50);
  });
  
  $('#inputText')?.addEventListener('input', e => {
    const caret = e.target.selectionStart;
    const before = e.target.value;
    const after = normalizeChineseText(before);
    if (after !== before) {
      e.target.value = after;
      e.target.setSelectionRange(caret, caret);
    }
    renderSegmented();
  });

  // Dictionnaire
  $('#loadDict')?.addEventListener('click', () => $('#dictFile').click());
  $('#dictFile')?.addEventListener('change', e => {
    const file = e.target.files[0];
    if (!file) return;
    const reader = new FileReader();
    reader.onload = () => {
      dict = parseCedict(reader.result);
      document.getElementById('dictStatus').textContent = 'Dictionnaire chargé (' + dict.wordSet.size + ' mots)';
      renderSegmented();
    };
    reader.readAsText(file, 'utf-8');
  });

  // 1️⃣ Cocher "Tout afficher sur la sélection" par défaut
  const alwaysShowSelected = document.getElementById('alwaysShowSelected');
  if (alwaysShowSelected) alwaysShowSelected.checked = true;

  // 2️⃣ Cacher / montrer les sous-options Pinyin sur l'accueil
  const readModeRadio = document.getElementById('readMode');
  const gameModeRadio = document.getElementById('gameMode');
  const pinyinSubOptions = document.getElementById('pinyinSubOptions');

  const syncPinyinSubOptions = () => {
    if (!pinyinSubOptions) return;
    if (readModeRadio?.checked) {
      pinyinSubOptions.style.display = 'none';
    } else if (gameModeRadio?.checked) {
      pinyinSubOptions.style.display = 'block';
    }
  };

  syncPinyinSubOptions();
  readModeRadio?.addEventListener('change', syncPinyinSubOptions);
  gameModeRadio?.addEventListener('change', syncPinyinSubOptions);

  // 3️⃣ Masquer la barre de vitesse si "Uniquement les mots sélectionnés" est coché
  const speedControl = document.getElementById('speedControl');
  const flowStop = document.getElementById('pinyinFlowStop');
  const flowSelectedOnly = document.getElementById('pinyinFlowSelectedOnly');

  function updateSpeedVisibility() {
    if (!speedControl) return;
    if (flowSelectedOnly?.checked) {
      speedControl.style.display = 'none';
    } else {
      speedControl.style.display = '';
    }
  }

  flowStop?.addEventListener('change', updateSpeedVisibility);
  flowSelectedOnly?.addEventListener('change', updateSpeedVisibility);
  updateSpeedVisibility();

  // 4️⃣ Active le glisser-déposer mobile
  try { enableMobileDnD(); } catch (_) {}

  // 5️⃣ Assure la présence de l'option "Révélation rapide"
  try { ensurePinyinFastOption(); } catch (_) {}

  // Premier rendu
  renderSegmented();
  wireGhostBar();
  showMenu();
});


// ===== Fonctions utilitaires =====
function closeTonePicker(acceptBase = true) {
  const picker = document.getElementById('tonePicker');
  if (acceptBase && pendingVowel) {
    pinyinInput[currentCharacterIndex] += (pendingVowel === 'ü' ? 'u' : pendingVowel);
    updatePinyinInputBoxes(); // <- Correction ici aussi
  }
  if (picker) picker.classList.remove('active');
  tonePickerOpen = false;
  pendingVowel = null;
}

function closeUChoice(acceptU = true) {
  pinyinInput[currentCharacterIndex] += acceptU ? 'u' : 'ü';
  updatePinyinInputBoxes();
  const chooser = document.getElementById('uChooser');
  if (chooser) chooser.classList.remove('active');
  uChoiceOpen = false;
}

function isLetterKey(k) {
  return /^[a-z]$/i.test(k);
}

function isReadBlocked() {
  return isPinyinGameMode() && pinyinFlow === 'selectedOnly';
}

// ========= Pickr =========
const bgColorPicker = Pickr.create({
  el: '#bgColorPicker',
  theme: 'classic',
  default: '#FFE103',
  components: { preview: true, opacity: true, hue: true, interaction: { hex: true, rgba: true, input: true, save: true } }
});

const textColorPicker = Pickr.create({
  el: '#textColorPicker',
  theme: 'classic',
  default: '#000000',
  components: { preview: true, opacity: true, hue: true, interaction: { hex: true, rgba: true, input: true, save: true } }
});

const highlightBgColorPicker = Pickr.create({
  el: '#highlightBgColorPicker',
  theme: 'classic',
  default: '#000000',
  components: { preview: true, opacity: true, hue: true, interaction: { hex: true, rgba: true, input: true, save: true } }
});

const highlightColorPicker = Pickr.create({
  el: '#highlightColorPicker',
  theme: 'classic',
  default: '#FFE103',
  components: { preview: true, opacity: true, hue: true, interaction: { hex: true, rgba: true, input: true, save: true } }
});


</script>

</body>
</html>
